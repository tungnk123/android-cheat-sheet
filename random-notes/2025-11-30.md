
---
1. **What to Do When Your Server Doesn’t Support Enums (Jetpack Compose Example)**
	- Enums are a developer’s best friend: they give us **type safety**, **clear domain models**, and prevent invalid data from creeping into our applications.
	- Firebase Realtime Database, for example, is a flexible JSON store — it **doesn’t know what an enum is**.
	- **The Solution: Map Strings to Enum in App Code**
	- The key idea: **store strings in Firebase**, but **convert them to enums in my app, and provide fallback values.**
2. **Paging 3 + Jetpack Compose**
	- Paging 3 (a library from the Android Jetpack set of libraries) takes away the headache of handling pagination state
	- Based on Google's internal metrics, that means apps using Paging 3 also have **60% less memory leaks** and significantly **higher user retention** than manual pagination.
	- The reactivity of Compose results in reactive lists and columns with the combination of LazyColumn + Paging — Paging manages the list state and tiles on a per-page basis.
3. Modern Android techstack: **MVI + GraphQL + Compose**
	- sealed class UiState: data, loading, error
		=> in case better solution is data class with all fields you need for state. sealed interface is good for actions (intent) and effects, coz you don't interest of previus actions.
	- sealed interface UiIntent: actions
	- sealed interface UiEffect: for inter ads
	- abstract class BaseMviViewModel<  
		I : UiIntent,  
		S : UiState,  
		E : UiEffect  : ViewModel(), IntentHandler<I/> { }
	- By the way, speaking about the UiState, having it modeled with **sealed classes/interfaces** makes it **difficult** to handle progress **and** errors **when** they are **inlined with the content**. A **single UiState data class** with nullable progress and error properties, for example, is easier to handle UI-side.
	- please don't manipulate with mutable state flows by state.value, especially for multiple fields states, keep it state.update { }, if you don't want to play with race conditions hell