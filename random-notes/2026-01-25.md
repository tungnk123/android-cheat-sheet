
---
1. Android Interview Questions Every Developer Must Know (2026 Guide)
	- Difference between `ViewModel` and `SavedInstanceState`
		- `ViewModel`: Retains data in memory during configuration changes (like rotation). Destroyed when the associated Activity/Fragment is finally finished.
		- `SavedInstanceState` (`Bundle`): Saves small, serializable data (like IDs) for process death restoration. Used in `onSaveInstanceState()` and `onCreate()`.
		- Use them together: store minimal identifiers in the Bundle, reload full data in the ViewModel.
		- Use `SavedStateHandle` with ViewModel to automatically save/restore data to the Bundle.
	- Live data vs flow:
		- Livedata cons: Tied to Android; can't be used in pure Kotlin modules, Limited transformation operators.
		- Flow: Rich operator ecosystem (`map`, `combine`, `filter`), More explicit about emissions (replay config).
		- Use `SharedFlow` with `replay=0` for one-time events to avoid the "event consumption" pitfalls of LiveData.
	- Explain Testing in Android (Unit, Instrumented, UI) -> Testing Pyramid
		- Unit Tests (JVM): Test business logic in isolation (ViewModel, Use Cases). Use JUnit, Mockito, Kotlin Coroutines Test.
		- Instrumented Tests (Android Device/Emulator): Test code with Android dependencies (Database, Repository). Use Espresso for UI, Room in-memory database.
		- UI Tests (End-to-End): Test user flows. Use Espresso or Jetpack Compose testing APIs.
		- Discuss Test Driven Development (TDD), Hermetic Testing (mocking all external dependencies), and using Hilt for Dependency Injection Testing.
2. Performance Optimization (Baseline Profiles, Startup Time)
	- Generating Baseline Profiles, analyzing with Macrobenchmark, reducing APK size with R8/resConfigs.
3. Navigation Component (Single Activity Architecture)
	- Explanation: Framework for in-app navigation with arguments and deep links.
	- Advanced: Nested graphs, dynamic feature navigation, testing NavController.
4. Coroutine Dispatcher knowledge:
	- The dispatcher controls:
		- **Thread allocation**: Which thread(s) execute your code
		- **Thread pool management**: How threads are reused and shared
		- **Execution context**: Whether code runs on the main thread, background pool, or custom executor
	- Drawbacks: **ANR**, **CalledFromWrongThreadException**, **Thread starvation, Wasted resources**
	- `Dispatchers.Main` uses Android's `Handler` and `Looper` under the hood. When you dispatch work to Main, it posts a `Runnable` to the main thread's message queue