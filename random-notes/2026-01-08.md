1. **üß† All knowledge summary (concise, short)**
	- **ExoPlayer / Media3**
		- `isPlaying` can emit **before** `STATE_BUFFERING`
		- UI must **prioritize** `**isBuffering**` **over** `**isPlaying**`
		- Force `isBuffering = true` when setting new media
		- Control state order, don‚Äôt trust callbacks blindly
	- **BottomSheetBehavior**
		- Setting `state` in setup causes reset on resume
		- To always expanded ‚Üí set `STATE_EXPANDED` in `onResume()`
		- BottomSheet does **not auto-collapse** on outside click
		- Use transparent overlay or map click to collapse
	- **Mapbox**
		- Mapbox **consumes touch events**
		- Never use `setOnTouchListener` on `MapView`
		- Use **Gestures plugin**:
		- `addOnMapClickListener` for tap
		- `OnMoveListener` for drag
		- Overlay view is best for preview maps
	- **Room / Database**
		- `@Insert` can return **auto-generated ID**
		- Use `suspend fun insert(): Long`
		- Returned ID = rowId
		- `OnConflictStrategy.REPLACE` may change IDs
		- Don‚Äôt re-query DB to get inserted item
	- **Architecture / Best practices**
		- UI state should be lifecycle-driven
		- Separate setup logic vs behavior logic
		- Prefer explicit state over implicit timing
		- Avoid race conditions with Flows & callbacks
2. collect vs collectLatest
	- Processing all emitted values (e.g., logging, downloading files sequentially) ‚Äî `collect{}`
	- Live search feature (cancel previous search if a new one starts) ‚Äî `collectLatest{}`
	- API polling (fetch new data without canceling old requests) ‚Äî `collect{}`
	- Typing in a search bar (show results for the latest query only) ‚Äî `collectLatest{}`
	- Live location tracking (discard old locations, keep only the latest one)- `collectLatest{}`
3. **A user performs a search, which triggers a network request. If the network fails, you must retry the request up to 3 times, with a 2-second delay between attempts. How do you implement this cleanly with Flow?**
	- Error handling is critical. Simply wrapping a call in `try-catch` isn't enough. Flow provides powerful declarative operators like `retry` for this exact scenario.
    
	- The `**retry**` operator can re-subscribe to the upstream flow if it encounters an exception. We can use it to specify the number of retries and add a delay.
  4. **In a** `**Fragment**`**, you collect a** `**Flow**` **that updates the UI. How do you ensure collection starts only when the UI is visible (**`**STARTED**`**) and stops when it's not, to prevent memory leaks and crashes?**
	  - The recommended approach is to use the `repeatOnLifecycle` API within a coroutine launched in `viewLifecycleOwner.lifecycleScope`.

5. handle backpressure: conflat()m, buffer(), collectLatest {}
6. **You are implementing a search-as-you-type feature. For each character typed by the user, you trigger an API call. How do you ensure you only process the result for the latest search query and cancel any in-flight requests for previous queries?**

-> Use `debounce` to wait for the user to stop typing, `filter` to avoid empty queries, distinctUntilChanged(), and `flatMapLatest` to execute the network call, launchIn


7. **How would you write a unit test for a** `**ViewModel**` **function that collects from a repository** `**Flow**` **and updates a** `**StateFlow**`**?**

	- For Flows, the `kotlinx-coroutines-test` library provides tools like `runTest` and `TestDispatcher` to control time and execution, making tests fast and predictable.
	- You can use a library like Turbine for a fluent API to assert emissions over time.
8. **For each user click (a** `**Flow<Unit>**`**), you need to perform two sequential network calls: first fetch a token, then use that token to fetch data. How do you ensure the entire sequence for one click finishes before the sequence for the next click begins? -> flatMapConcat**
9. ‚ùì _If a new observer subscribes later, should it receive the last value immediately?_
	- **YES** ‚Üí State
	- **NO** ‚Üí Event
	- Events: Toast / Snackbar, navigation, Websocket frame, chat message, error event, permission request, analytics log State: Loading flag, Current user, current data, playback state
	- Chat message with stateflow:
		- Replayed old messages		    
		- Duplicate notifications
		- Broken semantics