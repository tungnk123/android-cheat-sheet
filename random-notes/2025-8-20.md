map does not modify the original list.
It creates a new List<R>, where each element is the result of applying the lambda.
=> use forEach to modify the original list

How to update a immutable item in a immutable list?
	-> use var
	-> create a new list and update the object

Immutable list -> must use var to update one item or create a new list
	toMutableList(), toList() â†’ new mutable list instance.
	Each element in the list has the same element references 
	When you call toMutableList() on a List (immutable), it will:
		Create a new MutableList instance (usually an ArrayList).

	=> Both are shallow copies (structure new, elements same).
	Copy the references of elements from the original list.
	Shallow copy â†’ elements are the same references.
	Structural changes (add/remove) are independent.
	Element mutations affect both lists if elements are mutable.

submitList() does not rebind the whole list: DiffUtil runs on a background thread and only updates changed items.
 	Performance cost is minimal, unless the list is very large and updated very frequently.
 	Optimizations if needed:
 	Create a new list only changing the required item.	
	Use DiffUtil payloads to avoid full rebinds.
 	Enable stableIds in RecyclerView.
 	Batch multiple changes before submitting.
ðŸ‘‰ For small to medium lists (up to a few thousand items), using submitList() is safe and efficient.
=> Must use DiffUtil

Common best practice: use an immutable list + copy item + submitList + DiffUtil payloads.
 	Update a single item: toMutableList() â†’ replace the item with copy() â†’ submitList().
 	For large lists with frequent updates: consider persistent collections, payloads, and batching updates.

WorkManager in 2025: 5 Patterns That Actually Work in Production
	Pattern #1: The "Smart Retry" â€” Why Most Developers Get Exponential Backoff Wrong
		Distinguishing between retryable and non-retryable failures. When Airbnb implemented this pattern, they saw a 
		60% reduction in unnecessary retry attempts and improved user battery life significantly.

		return try {
            		performUpload()
            		Result.success()
        	} catch (e: NetworkException) {
            		when {
                		retryCount >= MAX_RETRIES -> Result.failure()
                		isTemporaryNetworkIssue(e) -> Result.retry()
                		else -> Result.failure() // Don't retry on permanent failures
            		}
        	} catch (e: ServerException) {
            		when (e.code) {
                		in 500..599 -> Result.retry() // Server errors - retry
                		else -> Result.failure() // Client errors - don't retry
            		}
        	}

	Pattern #2: The "Constraint Orchestra" â€” How to Make Multiple Conditions Play Nice
		Instead of rigid constraints that prevent execution, you check conditions inside the worker and adapt behavior 
		accordingly. Spotify uses this pattern for their offline sync, and it increased successful sync rates by 340%.

	Pattern #3: The "Progress Guardian" â€” Making Long-Running Tasks User-Friendly
		setProgress
		You also need to observe and display this progress

		WorkManager.getInstance(context)
    			.getWorkInfosForUniqueWorkLiveData("upload_work")
    			.observe(this) { workInfos ->
        			val workInfo = workInfos?.firstOrNull()
        			workInfo?.let {
            			val progress = it.progress.getInt("progress", 0) }
	Pattern #4: The "Cancellation Choreography" â€” Graceful Exits That Actually Work
		catch (e: CancellationException) {
            		// Clean up any partial downloads
            		cleanupPartialFiles()
            		Result.failure()
        	}

		the real secret is handling cancellation from the UI side
	Pattern #5: The "Resource Sentinel" â€” Preventing the Memory Apocalypse
		resource management in background workers
		private val maxMemoryUsage = Runtime.getRuntime().maxMemory()
		processBatch()

lazy usecase
	Needs resources available only later (requireContext, requireView, data from server)
		private val myAdapter by lazy { MyAdapter(requireContext()) }
		override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                	recyclerView.adapter = myAdapter // safe: context is ready here
            	}
	Heavy objects used rarely (Retrofit, Room DB, Dialogs)
	SharedPreferences or DataStore
	NavController or Views (only valid after onViewCreated)
	Room Database singleton
	Dialog that may never be shown
	Animations / Interpolators used rarely
	WorkManager, ClipboardManager, InputMethodManager
	BitmapDecoder / JSON parser

You can use both @Parcelize and @Serializable together.
 	They serve different purposes:
 	@Parcelize â†’ Android Parcelable (pass objects via Intent/Bundle).
 	@Serializable â†’ Kotlinx serialization (JSON encode/decode).
 	No conflict; they work independently.
 	Slight overhead, but negligible in practice.
 	Common pattern if you need both JSON parsing and object passing between components.

