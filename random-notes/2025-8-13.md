Dont create InputMethodManager every input click -> move to top

Anvil (by Square) is a Kotlin code-gen plugin for Dagger that:
	Removes most @Module/@Component boilerplate.
	Avoids kapt for faster builds.
	Lets you use annotations like @ContributesBinding to auto-generate Dagger bindings.
	Works well for multi-module DI setups.

@JvmOverloads in Kotlin generates multiple overloaded constructors or methods for Java when you have default parameter values.
	With it: => Java can call your class/method without passing all parameters.
	Without it:
 		Java must pass all parameters, even those with defaults.
 		Kotlin-to-Kotlin calls are unaffected.
	=> Use it only if Java code needs to call your Kotlin code conveniently.

Mastering Android Compose UI Performance: A Comprehensive Guide
	3 phase
		Composition: Creating UI descriptions through composable functions
		Layout: Measuring and positioning UI elements
		Drawing: Rendering elements to the screen

	The golden rule: stay under 16ms per frame to maintain 60fps.

	Performance Optimization Techniques
		1. State Hoisting and Immutability
		2. Strategic remember Usage
			Remember performs memoization — caching results to prevent recalculation.
		3. LazyList Optimizations
			// Stable keys prevent unnecessary recompositions during list updates
        		key = { item -> item.id },
        		// Content padding without wrapper composables
        		contentType = { item -> item.type } // For recycling similar items

		4. Modifiers Best Practices -> use remember 
		5. Baseline Profiles

	Common Performance Pitfalls
		1. Animation Performance
			Manual animation -> lag -> Using animateXXXAsState
		2. Expensive Operations in Composition
			Doing heavy work during composition -> Use remember and LaunchedEffect

	Q: “Explain how Compose’s smart recomposition works and how you can optimize for it.”
		-> Use immutable parameters when possible
		Implement proper equals() and hashCode() for custom classes
		Use primitive types where appropriate

	Q: “How can Compose’s declarative nature lead to memory issues, and how do you prevent them?”
		-> Captured References: Lambdas capturing objects
		Excessive Remember: Storing large objects
		Composition Local Abuse: Storing heavy objects in CompositionLocal

	State Management Cheatsheet for Composable Performance Optimization
		State Hoisting
		Remember with Keys: Use remember(key1, key2) with precise dependency keys to cache computations or objects
		Stable Types: Use data classes, immutable collections, and primitives which are inherently stable. 
			=> Compose optimizes recompositions better with stable types.	
		derivedStateOf: Use derivedStateOf { } for derived state calculations rather than calculating them directly in the 
			composable. This prevents recomposition when the calculation result is the same.
		Composition Locality: Break your UI into smaller composables with their own state to prevent the entire screen 
			from recomposing.
		LazyListItem Keys: Always provide stable, unique keys for items in LazyColumn/LazyRow to prevent unnecessary 
			recompositions and improve recycling.
		Immutability: Use immutable state objects and replace the entire object when changes occur rather than mutating 
			properties.
		produceState: Use for converting non-Compose state sources (like Flow or LiveData) into Compose state without triggering extra recompositions.
		Use rememberSaveable: For state that should survive configuration changes instead of regular remember.
		State Holders: Extract complex state logic into separate state holder classes outside composables (like ViewModels 
			or custom state classes).
		Use collectAsState() Correctly: When converting Flows to State, use collectAsState() at the right composition level 
			to prevent unnecessary recompositions.
		SideEffects for Non-UI Work: Use LaunchedEffect, DisposableEffect, and other side effect APIs for operations that 
			shouldn't trigger recomposition.
		Avoid Observable Mutable State: Don’t use observable mutable state objects directly in composables as changes will 
			trigger recompositions.
		Skippable Recomposition: Use Modifier.composed or wrap parts of your UI in lambda functions using let to make 
			certain parts skippable during recomposition.
		Measure and Profile: Use Layout Inspector and Compose metrics in Android Studio to identify unnecessary recompositions.
		