1. **Advanced Kotlin Magic: Unlocking the Power of `'combine'` for Android Development!**
	- The Initial Approach:  it leverages `async` and `await`pattern to launch **concurrent** **coroutines** for each request, enhancing performance.
	- `combine` provides a concise and readable way to handle **multiple flows**, making your code **easier** to understand and **maintain**.
	- `combine` allows for reactive updates to your UI state, ensuring it always reflects the latest data.
	- `combine` offers flexibility in how you handle the combined values, allowing you to perform additional **transformations** or calculations before **emitting the final result**.
	- `async/await` is for **one-shot** concurrent work that produces **one value and then finishes**.
		- “Call API A and API B in parallel, then merge their results once.”
		- “Calculate three expensive things at the same time, then do something with all three.”
	- `Flow` + `combine` is for **ongoing streams** of values that can **keep emitting** and update the UI reactively.
	- By consuming the flow eagerly (`firstOrNull()`), you:
		- Lose the connection between data source and UI
		- Lose all **backpressure** / cooperative cancellation semantics of Flow
		- Lose the ability to easily debounce, throttle, map, filter, retry, etc. with Flow operators
	- `combine` keeps everything inside the Flow world, so you can:
		- Add `.catch {}` for error handling
		- Add `.debounce()` or `.distinctUntilChanged()` for optimization
		- Add `.map {}` to transform states
		- Expose `_uiState` as a `StateFlow` and just observe it from the UI
	- Refactor Key points:
		- Use `viewModelScope.launch(ioDispatcher + handler)` directly.
		- Let `loadScreenData` be `fun`, not `suspend` (common pattern in ViewModels).
		- The `try/catch` is inside the coroutine that’s actually doing the work.
	- Use **`async/await`** when:
	    - You have a few **suspend** functions that each return **one value**, and
	    - You want to run them in parallel and combine them once.
	- Use **Flows + `combine`** when:
	    - Your data can change over time (database, network updates, live scores, etc.)
	    - You want the UI to stay in sync reactively.
	    - You care about composition, operators, backpressure, and lifecycle.
2. **RecyclerView Anti-Patterns**
	- Set listener in BindViewHolder:
		- we could transfer it inside `ViewHolder` initialization or onto `onCreateView`, then it will only be executed one time and will be recycled for later use.
		- Set listener on init on CreateViewHolder
	- The second anti-pattern is having logic inside the adapter.
		- The adapter and ViewHolder should do the job of showing ViewHolders to the user and not anything else.
		- Use interface callback or high-order functions
	- The third anti-pattern is the changing the state of the view directly inside the `ViewHolder`
		- Use a var properties -> more complexity in Adapter
			- One way to abstract this is to offload these select, unselect, add, remove whatever logic onto our **presenter/ViewModel**, and make the adapter **only accept a fresh list** every time the callers want to update the items.
		- Use an immutable list + DiffUtil (all of this diffing is done in a background thread)
3. IME (Input Method Editor)
	- **IME** = the **soft keyboard system** on Android.  
	- It controls:
		- which keyboard buttons appear
		- actions like **Search**, **Done**, **Go**, **Next**
		- input behavior for EditTexts
	- You control IME via `imeOptions`.
	- etSearchBox.setOnEditorActionListener { _, actionId, _ ->
	    if (actionId == EditorInfo.IME_ACTION_SEARCH)
4. BottomSheetBehavior.from(binding.fvBottomAction).apply {  
            state = BottomSheetBehavior.STATE_EXPANDED  
            isDraggable = true  
            isHideable = false  
        }  
}