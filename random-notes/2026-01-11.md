1. Can a `suspend` function block a thread? Explain with an example.
	- Yes, a **suspend function can absolutely block a thread.**
	- If the code inside that function performs a heavy, synchronous task without switching dispatchers, the thread it is running on will be blocked.
	- **JSON Parsing:** Using `Gson` or `Kotlinx.serialization` on a massive 10MB string inside a `suspend` function called from the UI.
	- **Image Processing:** Bitmaps manipulation or filtering logic.
	- **CPU-Bound Loops:** Running complex algorithms (like sorting thousands of items) without calling `yield()`.
2. Why might `Dispatchers.IO` degrade performance if used improperly?
	- If you use `Dispatchers.IO` for heavy CPU work (like image processing or large JSON parsing), the system may spawn dozens of threads simultaneously.
	- The CPU spends more time **context switching** (swapping which thread is currently using the processor) than actually executing your code. This overhead makes the overall task take longer than if you had used a smaller pool.
3. How would you identify a memory leak that does **not** appear in LeakCanary?
	- If a leak doesn't appear in LeakCanary, it's usually because the leak doesn't involve a **destroyed Activity or Fragment**.
	- If your leak involves "headless" objects like singletons, custom managers, or background coroutines that don't hold a reference to a Context, LeakCanary will remain silent.
	- You must use **Heap Dump Analysis** and **Allocation Tracking**.
4. Prevent coroutine leaks:
	- 1. **Structured concurrency everywhere** No `GlobalScope`. Provide DI'd scopes:
		- `viewModelScope` for UI logic.
		- `viewLifecycleOwner.lifecycleScope` + `repeatOnLifecycle` for Fragment collections.
		- `applicationScope` for truly app-long tasks (owned by a singleton with explicit shutdown).
	- 2. Handle the `CancellationException`
		- If you wrap your code in a `try-catch` block that swallows all exceptions, you might accidentally block the cancellation process. so you must rethrow to allow cleanup
	- 3. Use yield() or isActive in CPU-Heavy Loops
		- Coroutines are cooperatively cancelled.
		- If you have a `while(true)` loop doing heavy math, it will **never stop**—even if the scope is cancelled—unless you check for cancellation.
5. Config change handling?
	- **My state management stack**
		- **ViewModel** Holds UI state in memory and **survives configuration changes** like rotation. Best for data needed while the process is alive.
		- **SavedStateHandle** Lightweight, Bundle-backed storage. Used for **small, critical UI state** that must survive configuration changes and short-term process recreation. Fast and size-limited (recommended under ~1MB).
		- **Proto DataStore** Disk-based persistence. Used for **process death scenarios** (app swiped away, low-memory kill). Ensures state is restored even when the app is relaunched.
	- **UI strategy**: I follow an **optimistic UI** approach:
		- Render immediately from cached or in-memory state
		- Trigger full async reload in the background This ensures fast visual restore and good user experience.
	- **Complex objects in SavedStateHandle** Avoid storing large or complex objects. Use **Proto DataStore schemas** instead.
6. ViewModel destruction timing?
	- A ViewModel is destroyed **only when its ViewModelStoreOwner is permanently destroyed** and calls `clear()` on its `ViewModelStore`.
	- A ViewModel is cleared when its owner is permanently removed, for example:
		- **Activity**
			- `finish()`
			- `finishAffinity()`
		- **Fragment**
			- Removed via `FragmentTransaction.remove()`
			- Popped permanently from back stack
		- **Navigation graph**
			- Nav graph is popped (`NavController.popBackStack(graphId, true)`)
		- `ViewModelStoreOwner.clear()` is called
	- 