1. *Why do we use **`suspend`** **functions in Kotlin? Why not just use callbacks or regular functions?**
	- `suspend` marks a function that can pause and resume without blocking the thread, letting you write asynchronous code sequentially and safely.
	- **What** **`suspend`** **does:** It lets the function suspend its execution at certain points and resume later. Suspension is cooperative — the function yields control without blocking the underlying thread.
	- **No thread blocking:** Unlike long-running work on the main thread (which would freeze the UI), `suspend` allows work to move to another dispatcher (e.g., `Dispatchers.IO`) while the original thread remains free.
	- **Cleaner code than callbacks**: Callbacks create nested code (callback hell) and make error handling and sequencing harder. `suspend` functions let you write sequential-looking code (`val user = fetchUser()`), which is easier to read and maintain.
	- **Better error handling:** Use standard `try/catch` around `suspend` calls instead of handling errors in many callback callbacks.
	- **Composability:** `suspend` functions can be combined with coroutine builders (`launch`, `async`) and structured concurrency, making cancellations and scope lifecycle easier.
	- **Why not only callbacks or threads?**
		- Callbacks: error-prone, hard to cancel, harder to read.
		- Raw threads: heavyweight, expensive, and manual management of lifecycle/cancellation.
		- `suspend` + coroutines = lightweight, structured, cancellable, readable.

2. When should you use `Flow`? Why use `Flow` instead of `LiveData` or callbacks? What happens if you replace Flow with LiveData?
	- Use `Flow` for reactive streams of data (cold streams, operators, backpressure control, functional composition). 
	- `LiveData` is UI-centric and tied to Android lifecycle; Flow is more powerful, testable, and widely usable.
	- **Cold vs hot streams:** `Flow` is cold by default — it runs only when collected. `LiveData` is hot — it keeps emitting and holds the last value for active observers.
	- **Operators and transformations:** `Flow` has a rich set of operators (`map`, `flatMapLatest`, `buffer`, `debounce`) to transform and combine streams. `LiveData` has `map`/`switchMap`, but fewer operators and less functional power.
	- **Backpressure handling:** `Flow` supports buffering, conflation, and sampling to handle producers faster than consumers. `LiveData` doesn't give such explicit control.
	- **Platform independence & testing:** `Flow` is pure Kotlin — usable in JVM modules, tests, and non-Android layers. `LiveData` is Android lifecycle-aware, so harder to use in plain unit tests without Android testing tools.
	- **Interoperability with Coroutines:** `Flow` integrates naturally with coroutines and structured concurrency. You can `collect` within coroutine scopes and cancel easily.
	- **When to use LiveData:** Use LiveData when you only need simple, lifecycle-aware data for UI (especially in legacy apps). But prefer `StateFlow`/`SharedFlow` or `Flow` for new code in ViewModel → UI patterns.
	- **If you replace Flow with LiveData (effects):**
		- **Loss of operators and backpressure controls.**
		- **Harder to test without Android framework.**
		- **Potential memory/logic issues** if you rely on cold behavior or want multiple collectors with different lifetimes.
		- **But** LiveData simplifies lifecycle handling for UI observers (it auto-unsubscribes when lifecycle stops).
3. **ObjectAnimator** in Android
	- `ObjectAnimator.ofFloat()`
	- Animate rotate something

4. **Bug in `map` and `copy`**
	- `item.copy(isSelected = false)` → creates a **new AzkarNote** with `isSelected = false`; returns a `List<AzkarNote>` — correct, immutable, works with DiffUtil.
	- `item.isSelected = false` → just **modifies the existing object** and returns `Unit`; produces a `List<Unit>` — wrong type for `updateData()`.
	✅ Use `copy()` for new list updates, or `forEach` if mutating in place.

