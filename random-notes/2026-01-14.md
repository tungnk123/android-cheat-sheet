1. withContext
	- Does **NOT** interrupt blocking Java calls
	- Cancellation is checked only at suspension points
	- Blocking calls keep running until finished
	    
	- `**runInterruptible**`
		- Makes blocking code **interruptible**
		- On coroutine cancel → **interrupts the thread**
		- Registers a cancellation handler
		- Calls `Thread.interrupt()` on cancel
		- Converts `InterruptedException` → `CancellationException`
		    
	- **Why** `**runInterruptible**` **exists**
		- Blocking Java APIs **ignore coroutine cancellation**:
			- `Thread.sleep`
			- `BlockingQueue.take`
			- `Socket.read`
			- JDBC
			- File I/O (some APIs)
    
	- `runInterruptible` **bridges coroutines ↔ Java threads** safely.
		- Coroutines cancel cooperatively.
		- Threads cancel preemptively.
		- `runInterruptible` is the bridge — use it only when needed. (Java, legacy)
	- Raw JDBC / SQLiteOpenHelper, java.io.File -> **runInterruptible**

2. Optimize:
	- Profile using **Android Studio Startup Profiler** to see hot spots.
	- Replace naive data structures with **optimized ones (SparseArray, HashMap)**.
	- Defer heavy initialization with **lazy / background thread**.
	- Use **immutable collections** for constants.
	- Regularly audit memory usage — startup lags are often hidden in **GC churn**
3. SaaS advice:
	- **Organic** Channels Worked Better Than Ads
	- **Localization** Had a Clear Impact
	- Building a Web Version
	- **Start with a simple landing page and collect emails before launch.**
	- **Focus on onboarding early.**
	- **Set real working hours and stick to them.**
4. Dispatchers.Main` Is Not a Thread.
	- `Dispatchers.Main` does **not** create a thread
	- It does **not** own a thread
	- It cannot exist without Android’s main thread
	- `Dispatchers.Main` is a **CoroutineDispatcher** whose job is to:
		- Schedule coroutine resumption
		- Target the **main thread’s Looper**
		- Post work into the **main message queue**
	- “_**`Dispatchers.Main_is a scheduler bound to the main Looper, not a thread. If the Looper is blocked, it can’t run.”
	- he **main thread is created by the runtime**
	- It runs a **Looper**
	- That Looper processes a **MessageQueue**
	- When a coroutine uses `Dispatchers.Main`, it:
		1. Suspends
		2. Resumes
		3. Posts itself to the **main Looper**
		4. Waits for the main thread to pick it up
	5. Optimize Room DB
		- Database Indexing
			- Think of it like a book’s index — instead of reading every page, you jump straight to page number.
			- indices = [  
					Index(value = ["createdAt"])  
				]
			- SQLite can find rows by **_createdAt_** without scanning the full table.
			- **Step 1:** We have no **_index_** on **_name_**, SQLite will scan whole table and check in every row
			- **Step 2:** Now it has filtered subset but those rows are not guaranteed to be in sorted by **_createdAt_** order and existing index can’t be reused after filtering.
			- **Step 3:** It will sort based on **_createdAt_** column and returns the result
			- **_Composite Index_**
			- These indexes will only give benefit if your table has large number of rows ( min. 1000+ ) or in situations where these queries are run frequently. So choose according to your use-case.
		- Curse of Select * — Size Matters ( At least in Room )
			- 