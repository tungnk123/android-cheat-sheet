
---
## Kotlin Flow Mistakes
1. Trap 1: CollectLatest Silently Cancels Your Work
	- **Use collectLatest only** when you can safely discard intermediate work.
2. Trap 2: Collecting Flow Without repeatOnLifecycle
	- Collecting a Flow directly in lifecycleScope.launch keeps running even when the UI is not visible. This wastes resources and may crash the app.
	- StateFlow is not lifecycle aware. **Always collect with repeatOnLifecycle**
3. Trap 3: Flow Stops After the First Exception
	- Any thrown exception terminates the upstream Flow. No further emissions are delivered.
	- **Place catch before collect. Use retry for transient failures.**
4. Trap 4: Cold Flow Re-runs Work for Each Collector
	- Cold flows execute their block from scratch every time you collect them — even inside different screens.
	- Cold flows restart for every collector. **Use stateIn or shareIn when work must be shared.**
5. Trap 5: Exposing MutableStateFlow
	- Leaking MutableStateFlow gives external code full control over your internal state.
	- **Expose only read-only StateFlow. Keep MutableStateFlow private.**
6. Trap 6: Misusing collectAsState() in UI
	- collectAsState() **does not stop collecting** when the UI is in the **background**. This can cause continuous emissions while the screen is not visible.
	- Prefer **collectAsStateWithLifecycle** for UI bindings. Use collectAsState only for always-running Flows.
7. Trap 7: Doing All Work Inside collect
	- Packing all logic inside collect creates an unstructured callback. Testing and cancellation become unpredictable.
	- Use operators for transformations. Keep collect for UI updates only.
8. Trap 8: Using Nullable StateFlow for Late Parameters
	- Using a nullable StateFlow as a "parameter holder" leads to timing issues and UI flicker.
	- Inject runtime parameters directly. Do not model “missing values” using nullable StateFlow.
	- @AssistedInject, @Assisted val id
9. Trap 9: Launching New Coroutines Inside collect
	- launch inside collect creates parallel coroutines that outlive the collector, making the flow graph unpredictable.
	- **For parallel work use flatMapMerge or dedicated operators.**