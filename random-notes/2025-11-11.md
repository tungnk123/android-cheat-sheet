
---
1. **Android 15 : Important changes for developers**
	- 1. Edge-to-Edge Display by Default
		- Edge-to-edge is on by default. The focus is now on reacting to insets correctly using WindowInsetsCompat
		- Uses `ViewCompat.setOnApplyWindowInsetsListener` (often with KTX extensions like `updatePadding`) to listen for `WindowInsetsCompat`. These insets tell you the size of the system bars.
	- 2. Screen Recording Detection
		- Apps can now be notified if their content is being recorded. Making your application more secure.
		- **Now (Android 15):** Use `DisplayManager` and `ScreenRecordingCallback`.
	- 3. HDR Headroom Control
		- Allows apps to control the HDR headroom to balance SDR and HDR content.
		- **Now (Android 15):** Use `[Window.setDesiredHdrHeadroom()](https://developer.android.com/about/versions/15/features#hdr-headroom)`.
	- 4. ApplicationStartInfo API
		- Get information about how your application was started. You can control the boot related operations here.
		- Use ActivityManager.getHistoricalProcessStartReasons() or register for ApplicationStartInfo.
		- Performance analysis
	- 5. Foreground Service: New mediaProcessing Type
		- For tasks like transcoding media, you should use the new `[mediaProcessing](https://developer.android.com/about/versions/15/changes/foreground-service-types)` foreground service type.
		- Declare the `mediaProcessing` type in your manifest. These services have a shorter timeout.
	- 6. elegantTextHeight Attribute Default Change
		- Elegant text height provides more vertical space for characters, which can improve readability, especially for languages with tall ascenders or descenders.
	- 7. Package Stopped State and BOOT_COMPLETED / User Interaction
		- `PendingIntent`s are explicitly cleared when the app package enters the stopped state.
		- The system delivers an `ACTION_BOOT_COMPLETED` broadcast to eligible apps _after_ they are no longer in the stopped state

2. async vs withContext vs launch
	- Late-initialized properties and variables
	- dependency injection or inside the setup method of a unit test
	- For class properties:
		- You can't declare them in the primary constructor.
		- They must not have a custom getter or setter.
	- In all cases, the property or variable must be non-nullable and must not be a primitive type.
	- launch(Dispatchers.IO): starts a new coroutine on the IO pool, returns a Job, no result.
	 - withContext(Dispatchers.IO): suspends the current coroutine, runs the block on IO, returns the block’s result.
	 - async(Dispatchers.IO): starts a new coroutine that returns a Deferred<T/>; you get the result via await() (structured way to do concurrency).
	
	- When to use
		 - launch(IO): fire-and-forget background work where you don’t need a value back.
		 - withContext(IO): you need to do IO within a suspend flow and return a value, then resume on the original context.
		 - async(IO): you want to kick off concurrent tasks that each produce a value and later await them (possibly in parallel).
	
	- Concurrency
		- launch(IO): Runs independently
		- withContext(IO): Inline, sequential within caller
		- async(IO): Can run many in parallel; await later
	
	- Fire-and-forget on IO => launch
	- Compute on IO and return value (sequential): withContext
	- Parallel requests, then combine: async
	
	- Use coroutineScope { ... } (or a structured scope like viewModelScope) around multiple async calls so they cancel together.
	
	- Quick rule of thumb
		 - Need a value now → withContext(IO)
		 - Need to do it in parallel and then combine → async(IO) + await()
	 - Need to just kick off background work tied to a scope → launch(IO)