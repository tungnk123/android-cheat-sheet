 **1. Annotations in Android (Kotlin context)**
An **annotation** is metadata attached to:
- class
- function
- field
- constructor
- parameter
It does **not execute code by itself**.
It is **read by tools**:
- compiler
- annotation processors (KAPT / KSP)
- runtime reflection

Example (Hilt):

```
@HiltAndroidApp
class MyApp : Application()
```

**2. Annotation Retention types (VERY important)**
Kotlin / Java annotations have **3 retention levels**:
**â‘  SOURCE**

```
@Retention(AnnotationRetention.SOURCE)
```

**Exists only in source code**

- âŒ Not in `.class`
- âŒ Not in runtime
- âœ… Used by **lint / IDE / compiler hints**

Use cases: 
- `@Suppress`
- `@Composable`
- `@Parcelize`

ğŸ‘‰ **Compiler sees it, bytecode does NOT**

**â‘¡ BINARY âœ… (Most DI / Retrofit annotations)**

```
@Retention(AnnotationRetention.BINARY)
```

**Exists in compiled** `**.class**`

- âœ… In bytecode
- âŒ Not visible via reflection at runtime
- âœ… Read by **annotation processors**
Use cases:
- Hilt
- Dagger
- Retrofit
- Room (mostly)

ğŸ‘‰ **Compiler + annotation processor see it**

**â‘¢ RUNTIME**

```
@Retention(AnnotationRetention.RUNTIME)
```

**Exists at runtime**

- âœ… Reflection can read it
- âŒ Slower
- âŒ Larger APK
- âŒ Proguard/R8 complexity

Use cases:
- JSON serialization (Gson old style)
- Custom reflection frameworks
- Testing frameworks

ğŸ‘‰ **Runtime code reads it**

**3. Hilt annotations = BINARY (why?)**

Example:

```
@AndroidEntryPoint
class MainActivity : AppCompatActivity()
```

Hilt uses:
- **KAPT / KSP**
- **Compile-time code generation**
Flow:

```
Source code
  â†“
Annotation Processor (KAPT/KSP)
  â†“
Generated Dagger code
  â†“
Final APK (NO reflection)
```

**Why NOT runtime?**
- No reflection needed
- Faster app startup
- Smaller APK
- Compile-time safety

ğŸ‘‰ Hilt = **BINARY is perfect**

**4. Retrofit annotations (æ ¸å¿ƒé‡ç‚¹)**

Example:

```
interface ApiService {
    @GET("users")
    suspend fun getUsers(): List<User>
}
```

Annotations:
- `@GET`
- `@POST`
- `@Query`
- `@Body`

**Retrofit uses BINARY, not RUNTIME â—**

Why?

**Retrofit processes annotations at build time**
- Generates request metadata
- Builds method â†’ HTTP mapping
- Avoids reflection at runtime (newer versions)
**Advantages:**
Reason
Explanation
ğŸš€ Performance
No reflection
ğŸ§  Type safety
Errors at compile time
ğŸ“¦ APK size
No runtime metadata
ğŸ” Proguard friendly
Less keep rules
âš¡ Faster startup
Critical on Android

**5. Why NOT RUNTIME for Retrofit?**
If Retrofit used `RUNTIME`:
- Every API call â†’ reflection
- Slower networking
- More memory
- More crashes with obfuscation

Old libraries used RUNTIME

**Modern Android avoids it**

**7. One-sentence answers (for interviews)**

- **Hilt uses BINARY** â†’ compile-time DI, no reflection
- **Retrofit uses BINARY** â†’ fast, safe, no runtime overhead
- **RUNTIME only when reflection is unavoidable**

**âœ… Knowledge summary (for you to note down)**
- Annotation â‰  code, itâ€™s metadata
- SOURCE â†’ compile hints only
- BINARY â†’ annotation processor reads it
- RUNTIME â†’ reflection reads it
- Hilt & Retrofit choose **BINARY** for **performance + safety**
- Modern Android avoids runtime reflection as much as possible


2. `**@Retention(RUNTIME)**` _**does**_ **increase APK / DEX size**, but **not because it adds â€œcodeâ€**, rather because it **adds metadata that must be kept**.

Runtime annotations are stored in `.class` / `.dex`

Larger `.class`

Larger `classes.dex`

Larger APK

**BINARY** â†’ compiler tools consume it â†’ can be optimized away

**RUNTIME** â†’ VM must keep everything

**It also blocks R8 optimizations**

Because reflection might access annotations:

R8 must:
- Keep annotation classes
- Keep annotation attributes
- Keep referenced types
- Avoid aggressive shrinking

`RUNTIME` annotations increase APK size because their metadata must be preserved in DEX for reflection and cannot be optimized away by R8.
`RUNTIME` does NOT add executable code
It adds **annotation metadata**
Metadata increases DEX & APK size
Blocks R8 shrinking
Android prefers BINARY over RUNTIME


