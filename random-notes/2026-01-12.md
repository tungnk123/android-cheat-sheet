1. collect vs collectlatest
	- Processing all emitted values (e.g., logging, downloading files sequentially) — `collect{}`
	- Live search feature (cancel previous search if a new one starts) — `collectLatest{}`
	    
	- API polling (fetch new data without canceling old requests) — `collect{}`
	    
	- Typing in a search bar (show results for the latest query only) — `collectLatest{}`
	    
	- Live location tracking (discard old locations, keep only the latest one)- `collectLatest{}`

2. Dependency Injection in Android: The Complete Guide to Writing Maintainable Code
	- contructor injection
	- pameter injection (method injecton)
		- you pass the dependency directly into the specific function (method) that needs it, only when that function is called. This is useful if the dependency is only needed for one specific task.
		- class ReportGenerator {
			    fun generate(data: ReportData, formatter: ReportFormatter): Report {
			        return formatter.format(data)
			    }
			}
	- property injection
		- dependencies be provided after construction
		- DI frameworks handle property injection for Android components automatically
	- The dependency relationships form a graph -> Depedency graph
	- DI: push vs Service Locator: Pull
	- Manual DI: hard to read, fix, lifecycle handling, scope handlig, awkward
	- DI framework: remove boilerplate code, manage lifecycles and scopes, catch errors early, testability, debug, memory overhead is controlled

3. DI
	- **Single Responsibility Principle**
		- a class should have only one reason to change.
		- By injecting dependencies from the outside, each class focuses on its own job rather than creating or configuring other objects.
    
	**- Dependency Inversion Principle (DIP)**
	- higher-level modules should not depend on lower-level modules directly; both should depend on abstractions.
	    
	- With DI, you can pass around an interface or abstract class instead of a concrete implementation.
    
	_Dagger’s name comes from_ _**DAG**__ger, where DAG stands for Directed Acyclic Graph_
	
	_Dagger analyzes your annotations at build time and generates code that constructs this graph in the correct order._
	
	uses compile-time code generation. It has two key strengths:
	
	- **Compile-Time Code Generation:** Dagger analyzes annotations at build time and generates wiring code before the app starts.
	    
	- **Strong Guarantees:** If your project builds, the dependency graph is validated. Missing bindings cause build errors.
    

	The `module { }` DSL defines how to build your dependencies. `single { }` creates singletons, `factory { }` creates new instances each time, and `viewModel { }` is specifically for Android ViewModels.
	
	The `get()` function is Koin's magic — it looks up the required dependency from the container automatically.
	
	If you want compile-time verification without switching to Hilt, Koin Annotations adds that layer: @Single, @KoinViewModel
	
	**Koin Compiler Plugin: Compile-Time Safety Meets Kotlin Simplicity:**
	
	- Your classes stay annotation-free, but you still get compile-time wiring.
	    
	- The compiler plugin provides automatic constructor injection. It transforms your concise DSL into fully wired code at compile time
	    
	- No more manual `get()` calls. No more forgetting a dependency. The plugin analyzes your constructors and generates the wiring automatically.
	    
	- single<ArticleRepository)()
	- factory(GetArticleUseCase)


4. `**@HiltViewModel**` **defines the ViewModel**
	- `**@ViewModelScoped**` **defines objects owned by that ViewModel**
	- Is this a helper / use case used by the ViewModel? -> ViewModelScoped
	- Do NOT scope UseCases
		Keep UseCases:
		- stateless
		- thin
		- cheap to create
