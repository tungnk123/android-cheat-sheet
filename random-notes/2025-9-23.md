Classic Android lifecycle vs AndroidX Lifecycle (KTX) states
	Classic lifecycle = callbacks you override (onCreate, onStart, onResume, onPause, onStop, onDestroy) and old diagrams that 
		show “Paused” and “Stopped” phases.

	AndroidX Lifecycle (KTX) = a state machine (Lifecycle.State) that libraries (Flow/LiveData/Navigation/ViewPager2) use to 
		start/stop work declaratively.

	onCreate() -> CREATED
	onStart() -> STARTED
	onResume() -> RESUMED
	onPause() -> back to STARTED (no PAUSED state in AndroidX)
	onStop() -> CREATED
	onDestroy() -> DESTROYED

	repeatOnLifecycle(State.RESUMED) → runs only when the screen is visible & interactive (current tab).
	repeatOnLifecycle(State.STARTED) → runs when the screen is visible but not in focus and when in focus. With ViewPager2, 		
		offscreen pages (within offscreenPageLimit) are kept at STARTED, so those blocks still run.
	Use RESUMED for heavy/interactive streams on pages/tabs; use STARTED when you want them active while visible but not focused.

	Current page: adapter sets maxLifecycle = RESUMED.
	Neighboring pages within offscreenPageLimit: STARTED (View exists; onPause() called; no onStop()).
 	Pages outside the limit: view destroyed (onDestroyView()), lifecycle ≤ CREATED.

Sync in Android
	Synchronization in Android refers to coordinating data between local storage and remote servers, ensuring consistency across 
	devices and handling offline scenarios.

	Key Points:
		Data consistency — Keep local and remote data in sync
		Conflict resolution — Handle simultaneous updates
		Offline support — Queue operations when network unavailable
		Battery optimization — Efficient sync strategies

	Best Practices:
		Offline-first approach
		Incremental sync — Only sync changes
		Conflict resolution strategies
		Battery optimization with constraints
		Error handling and retry logic

SetValue vs PostValue in Android (LiveData)
	setValue():
		Main thread only
		Synchronous
		Immediate update
		Direct assignment
		Main thread operations
		Immediate updates needed

	postValue():
		Any thread
		Asynchronous
		Posted to main thread
		Queued execution
		Network, file, db, background thread work

	setValue() must be called from the main thread and updates immediately, 
	while postValue() can be called from any thread and posts the update to the main thread's message queue for asynchronous execution.

	Important Notes:
		postValue() can lose intermediate values if called rapidly
		setValue() throws exception if called from background thread
		Modern apps prefer Coroutines over manual threading
		LiveData automatically handles thread switching with Coroutines
