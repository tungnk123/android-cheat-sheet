### 1. Avoiding Memory Leaks
- **Use static inner class**
    - Local classes, inner classes, and anonymous inner classes all hold implicit references to the outer class they are declared in.
    - Instead of using nested classes with outer class references, it is preferred to use static inner classes because **they reference only the global class object** and not the instance object.
- **Use Weak References**
    - So if the only remaining reference to the outer object is the weak reference from the inner class, the garbage collector sees this object as **eligible** for **garbage collection** and may **deallocate** the outer instance from the heap.
- **Stop worker thread execution**
    - Thread should be terminated as soon as it is not required anymore.
- **Retain Worker Thread**
    - By retaining the thread from the old to the new Activity and removing the thread reference from the old Activity, you can allow the Activity object to be garbage collected.
- **Clean Up the Message Queue**
    - If a message is pending when it is no longer needed, you should remove it from the message queue so that all its referenced objects can be deallocated.
### 2. Advanced Coroutine Patterns You Must Know
1. Creating a Custom Dispatcher for Specialized Sequential Tasks
	- You might have a **dedicated thread pool** for a **legacy** **Java** library, or you need to **limit** the **concurrency** of a specific set of operations
	- `val singleThreadDispatcher = Executors.newSingleThreadExecutor().asCoroutineDispatcher()`
	- **Don't forget to shut down your custom executor when it's no longer needed to prevent memory leaks!**
2. The `SharedFlow` for Hot, State-Aware Data Streams
	- Broadcasting one-time UI events
	- Creating an app-wide event bus.
3. Combining Flows with `zip` and `combine` for Synchronized Operations
	- `combine`: Use this when you need to react to the latest value from _any_ of the flows. The combined flow will emit a new item whenever one of the source flows emits. Perfect for reactive UIs where a change in one filter should update the results.
	- `zip`: Use this when you need to pair up emissions from multiple flows. The zipped flow will only emit a new item once _all_ source flows have emitted a corresponding item. It waits for everyone to be ready.
	- **Usecase**:
		- **`combine`**: A search screen where multiple filters (e.g., category, price range) are themselves flows, and the final list of results should update as soon as any filter changes.
		- **`zip`**: Fetching user details and user permissions from two different network calls and only proceeding once both have returned successfully.
4. Supervising Coroutines with `supervisorScope` for Fault Tolerance
	- It creates a scope where child coroutines are independent. If one fails, it doesn't propagate the cancellation upwards or sideways.
	- **When to use it:**
		- Launching multiple, non-critical network requests in a `ViewModel`, where you still want to display partial data if one request fails.
		- Running a set of background jobs that can operate independently of each other.
5. Using `CoroutineExceptionHandler` for a Global Error Strategy
	- A `CoroutineExceptionHandler` provides a centralized mechanism to catch and handle uncaught exceptions from your coroutines.
	- By adding it to the `CoroutineContext` of your top-level scope (like `viewModelScope`), you create a default safety net for any exceptions that aren't handled manually.
	- **When to use it:**
		- To implement a generic error logging strategy for your entire `ViewModel` or application.
		- To show a default error message to the user when an unexpected failure occurs.
		- To avoid your app crashing from an unhandled exception in a coroutine launched from a global scope.
6. SupervisorScope in depth
	- Why `supervisorScope` is needed even though `viewModelScope` is a supervisor?
	- **Key rule**
		- `viewModelScope` supervises **only its direct children**.
		- Inside a `viewModelScope.launch { ... }`, the inner children are **NOT supervised** unless you add `supervisorScope`.
	-  ![[supervisorScope_example.png]]
	- Alternative (no supervisorScope):
		- Make tasks direct children of `viewModelScope`:
			viewModelScope.launch { fetchNews() }
			viewModelScope.launch { fetchWeather() }
			viewModelScope.launch {
			    try { fetchPromotions() } catch(e: Exception) {}
			}

	- `viewModelScope` uses **SupervisorJob**, not `supervisorScope`.
	- `viewModelScope` already has a **SupervisorJob**, so **child coroutines are independent**
	- If you want **child coroutines inside ONE `launch`** to be independent from each other -> Use `supervisorScope`
	- You don’t need `supervisorScope` inside `viewModelScope` unless you specifically want parallel supervised children inside a single coroutine block.
	- **Don’t use `supervisorScope`** just to “get supervision” → you already have it.
	- Use `supervisorScope` when:
		- you’re _inside one_ `launch`
		- want **parallel children**
		- want them **independent**
		- and want to **wait for all** before continuing.
	- 
7. Fix push keys to Githubs
	- git filter-repo
	- git reset + git push --force