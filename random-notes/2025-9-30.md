itemView.context.resources.getFont(fontResId) 

Map<Int, Int> (e.g., HashMap, MutableMap)
 	General-purpose data structure.
 	Boxing happens: Int keys and values are wrapped into Integer objects on the JVM/ART.
 	Easier to read & use (idiomatic Kotlin/Java).
 	Rich API: filtering, mapping, iteration, etc.
 	Slightly higher memory & CPU overhead because of boxing/unboxing.
SparseIntArray
 	Android-specific container optimized for Int → Int.
 	Stores primitives directly → no boxing/unboxing overhead.
 	Usually more memory-efficient than HashMap<Int, Int> when you have lots of entries.
 	API is less idiomatic (no nice Kotlin features).
 	Access uses get(key, default) instead of map[key].
=> Use SparseIntArray
 	Large datasets (hundreds/thousands of int→int mappings).
 	Performance-critical (e.g., lookup inside audio timing, rendering loops).
 	When you want to avoid object allocations.
 Use Map<Int, Int>
 	When readability and Kotlin features matter more.
 	Small datasets (a few dozen entries, overhead negligible).
 	When you want rich operations like .map, .filter, etc.
=> Sparse only optimize for primitive key (Int, Long)

notifyDatasetChanged():
	Notify any registered observers that the data set has changed.
	There are two different classes of data change events, item changes and structural changes. 
	Item changes are when a single item has its data updated but no positional changes have occurred. 
	Structural changes are when items are inserted, removed or moved within the data set.

	This event does not specify what about the data set has changed, forcing any observers to assume that all existing items and 
	structure may no longer be valid. LayoutManagers will be forced to fully rebind and relayout all visible views.
	RecyclerView will attempt to synthesize visible structural change events for adapters that report that they have stable IDs when 
		this method is used. 
	This can help for the purposes of animation and visual object persistence but individual item views will still need to be 
		rebound and relaid out.

	=> Avoid notifyDataSetChanged() unless everything truly changes.
 	=> Use notifyItemChanged / notifyItemRangeChanged for targeted updates.
	=> For large or complex updates, use DiffUtil or ListAdapter → computes minimal changes and applies them with animations.

	Use payload in Adapter to only update a part of ViewHolder
	Whole dataset replaced → notifyDataSetChanged().

 	Many contiguous items updated → notifyItemRangeChanged(start, count).

 	Small field changes inside items → use payload for partial bind.

 	Complex updates (mix of add/remove/move/change) → use DiffUtil / ListAdapter.