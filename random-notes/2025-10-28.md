expression = block code returns a value
Statement = block code performs an action
In Kotlin, many constructs like if and when are expressions (they return values).
 ðŸ‘‰ In Java, they are statements (they donâ€™t).

You can use when either as an expression or a statement.
you can use when with or without a subject
Using a subject usually makes your code more readable and maintainable because it clearly shows what you're checking
when { ... }
Covering all possible cases is called being exhaustive.
Group multiple conditions into a single branch using commas

If you use when as a statement, you don't need to cover all possible cases.
If you use when as an expression, you must cover all possible cases.
The value of the first matching branch becomes the value of the overall expression. If you don't cover all cases, the compiler throws an error.

Locale.default().language != Locale.default().languageTag()


An array holds a fixed number of values of the same type (or subtype).
Use arrays when you need fixed-size, low-level collections; for general use, prefer Kotlin collections.
Arrays are mutable and invariant in Kotlin (you cannot assign Array<String> to Array<Any>)
Use the spread operator (*) with vararg when passing array elements as separate arguments.Use .contentEquals() or .contentDeepEquals() to compare array contents; == checks reference equality.
 Use functions like .sum(), .shuffle(), conversions .toList(), .toSet(), .toMap(). 

For better performance (avoiding boxing), use IntArray, BooleanArray, CharArray, etc instead of Array<Int> etc. 
 Primitive arrays are separate classes (not subclass of Array<T>) but provide similar functionality.
 Conversion: .toTypedArray() from primitive to object-type, and .toIntArray() etc for reverse.

=> Because arrays are fixed size and less flexible (no easy add/remove, equality behavior differs), for most cases Kotlin collections (List, MutableList, etc) are preferred.

indices in arrays, list
you can use the .withIndex()
for ((index, value) in routineSteps.withIndex())

Guard conditionsï»¿ in when
include more than one condition to the branches of a when expression or statement
=> making complex control flow more explicit and concise
if in when

Exceptions â†’ program-level issues you can handle.
Errors â†’ system-level failures you generally should not handle.

Throw exceptions with precondition functionsï»¿: require, check, error

The finally block is always executed, but it doesn't change the result of the try-catch block.