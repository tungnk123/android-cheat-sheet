1.  **Explain how you would structure a multi-module Android project to optimize build times and enforce boundaries.**
	- **Feature-by-Layer Split:** Organize by business verticals (e.g., `:feature:payment`) rather than technical layers (e.g., `:data`, `:ui`) to limit the "recompile-everything" effect.
	-  **The “API” Module Pattern:** For every feature, create a `:feature:payment:api` module containing only interfaces and DTOs. Other modules depend on this "thin" contract rather than the heavy "implementation" module.
	-  **Core-Utility Segregation:** Move stable, low-change code (Network, Database, Design System) into standalone `:core` modules to maximize build cache hits.
	-  **Flat Dependency Graph:** Avoid deep nesting (A -> b-> c -> d). A flat graph allows Gradle to maximize CPU core utilization for parallel execution.
	-  **Implementation Over API:** Use the `implementation` configuration for 95% of dependencies. This prevents "leakage" where a change in a low-level module triggers a recompile of every module above it.
	-  **Avoid Shared “Utils” Modules:** Giant `:utils` modules are build-time killers. If one utility changes, the entire app recompiles. Split them into granular `:core:date-utils`, `:core:auth-utils`, etc.
	-  **JVM-Only Modules:** Keep business logic in pure Kotlin/Java modules. They compile faster than Android Library modules because they bypass the Android Gradle Plugin (AGP) and resource merging.
	- **Convention Plugins:** Use `buildSrc` or `composite builds` with Kotlin DSL to define "Convention Plugins." This ensures all 50+ modules share identical, optimized compiler flags.
	- **Enable Configuration Cache:** Ensure all custom Gradle tasks are compatible with the Configuration Cache to skip the “Task Graph” calculation phase.
	- **Module Piling/Focus:** For developers, use a `local.properties` toggle to only include modules they are actively working on in the IDE.
	- **Internal Visibility:** Use the `internal` keyword extensively. Implementation classes should never be accessible outside their module; only the "API" interfaces should be public.
	- **Dependency Analysis Tools:** Use plugins like `Dependency Analysis Android Gradle Plugin` to detect unused dependencies or those that should be `implementation` instead of `api`.
	- **Strict Lint Rules:** Implement custom Lint or Konsist rules to prevent “illegal” imports (e.g., `:feature:login` importing from `:feature:dashboard`).
	- **Public Resource Prefixes:** Use `resourcePrefix` in `build.gradle` for core UI modules to prevent resource name collisions across features.
	- **Dagger/Hilt Scoping:** Use a centralized `:app` module for Dependency Injection wiring, ensuring features remain agnostic of who provides their dependencies.
	- Add CI/CD pipeline to check dependency of modules.
2. How do you design an app that must support dynamic feature delivery and dynamic navigation?
	- Do everything that describes above to support a good modular achitecture and along with that use Navigation lib to move between destintation of diff dynamic modules.  
	- Download the dynamic module when navigation is triggered.
	- Use `SplitInstallManager` , let’s check how to handle it when we are trying to install checkout flow from dynamic feature delivery.
3. How would you prevent tight coupling in a large codebase with hundreds of developers working concurrently?
	- Modularisation with strict dependency rules
	- Dependency inversion and facades
	- Data & navigation boundaries
	- Enforce module rules in Gradle
	- Visibility & API surfaces
	- Ownership & CODEOWNERS
	- Clear deprecation and evolution story
	- Design reviews & API reviews
4. Explain how you would structure your ViewModel layer to avoid shared-state bugs in Compose.
	- By using MVI architecture, which maintains ui state, events and effects nicely for all scenarios and diff ui states. Also not share the viewModel a lot between fragments.
5. Abstraction for flow, specialization for details, compile-time safety via sealed types, scalable for future item types (e.g., Podcast).
	- Use a sealed abstraction as a dispatcher:
	 - Implement PlayableItem.toMediaItem() that dispatches by type:
		when (this) {
		  is SongTrackEntity -> this.toMediaItem()
		  is RadioStationEntity -> this.toMediaItem()
		}