- The Dalvik VM is a **memory-managed system** that frequently reclaims allocated memory with the **garbage collector** (GC) from the shared memory, known as the **heap**, when it grows too **large**.
- A memory leak is sometimes strictly defined as **memory** allocated by
the application that is **not used anymore** but **never** **identified** by the
**GC** as **memory** that can be **reclaimed**.
- Hence, the memory is **occupied** until the **application process** is **terminated**.
- The GC can reclaim the memory when an object or its parents have **no more strong references** to it
- The Dalvik GC uses a very common **two-step mechanism** called **mark** and **sweep**.
    - The **mark** step traverses the **object trees** and **marks** all objects that are **not referenced** by anyother objects as **unused**.
    - **Unused objects become **eligible** for **garbage collection**, and the **sweep** step **deallocates** all the marked **objects**.
- An object is said to be **unused** if it is **unreachable** from any of the application’s **garbage collection roots**, which are **Java objects** acting as **starting** **points** for the **traversal** of the **object** **trees**.
- GC roots themselves are **not** considered **unused** or eligible for garbage collection, even though **no** **other** application object **references** them.

Kotlin Coroutines patterns & anti-patterns

Wrap async calls with coroutineScope or use SupervisorJob to handle exceptions
- This happens because the failure of any of the job’s children leads to an immediate failure of its parent.
	=> Using supervisor scope

- wrapping async with coroutineScope => Now when the exception occurs inside async it will cancel all other coroutines created in this scope, without touching outer scope

Prefer the Main dispatcher for root coroutine
- it’s preferable to create your scope with the Main dispatcher which results in simpler code and less explicit context switching.

Avoid usage of unnecessary async/await
- If you are using async function followed by immediate await you should stop doing this.
- If you want to switch coroutine context and immediately suspend parent coroutine withContext is a preferable way to do that.

Avoid cancelling scope job
- When you want to cancel all coroutines of a specific scope, you can use cancelChildren function. 

Avoid writing suspend function with an implicit dispatcher
* Don’t write suspend function which relies on execution from specific coroutine dispatcher.
* Design your suspend function in a way that it can be executed from any coroutine dispatcher.
* => Wrap UI call in withContext(Main) and background task in withContext (IO)

Avoid usage of global scope
- In Android coroutine can be easily scoped to Activity, Fragment, View or ViewModel lifecycle.
