
---
1. Desugaring in Android: The Magic Potion for Modern Kotlin on Every Device
	- Desugar = It’s the hidden translator that lets you write **Modern Kotlin** (which often compiles to modern Java bytecode) and have it run flawlessly on **legacy** devices.
	- Desugaring is your **Backward Compatibility Superpower**.
	- Before Desugaring, if you targeted an older device (like API 23), using `java.time` would crash your app. You'd be stuck with the complex, non-thread-safe `java.util.Calendar` or `SimpleDateFormat`.
	- D8 and R8 will do the magic under the hood:
		- code compilation
		- desugaring: - It **rewrites** the bytecode to redirect these calls from the original Java package (e.g., `java.time`) to an included backport library package (e.g., `j$.time`).
		- dexing: It bundles a separate DEX file containing the full implementation of these missing classes (like `j$.time.LocalDate`) into your final APK.
	=> Use case: support low minSdkVersion, use `java.time` and `java.stream`

2. Handle Room migration:
	- schema identity hash
	- room_master_table
	- // Destroy on ANY failed migration -> .fallbackToDestructiveMigration() 
	- // Destroy only when DOWNGRADING (e.g., version 3 → 2) -> .fallbackToDestructiveMigrationOnDowngrade() 
	- // Destroy only from specific versions -> .fallbackToDestructiveMigrationFrom(1, 2, 3)
	- With Room, if you change the database schema but don’t ==upgrade the version==, your app will crash. If you upgrade the version but don’t provide any migrations your app will crash or, the database tables are dropped and your users will lose their data.
	- change Room Database version
	- Please provide a Migration in the builder or call fallbackToDestructiveMigration in the builder in which case Room will re-create all of the tables.
	- **Add this migration to database builder and don’t forgot to change version number.**
	- What if user have an older version of app with database version 1 and upgrade to database version 3? So, we already added migration from 1–2 and 2–3. Room will trigger all migrations one by one.
	- We can also define manually migration for more than one version increment.
		- private val MIGRATION_1_3 = object : Migration(1, 3)
	- ## Automatic Migration (Simplified Approach)
		- Introduced in Room **2.4.0**, automatic migration helps generate migration scripts for simple schema changes.
		- autoMigrations = [  
				AutoMigration(from = 1, to = 2)  
			]
		- Auto-handled: 
			- Add new table
			- Add new column (with default)
			- Add new index
		- For deletions and renames, provide a spec
			- AutoMigration(from = 2, to = 3, spec = Migration2To3::class)
			- @RenameColumn(tableName = "users", fromColumnName = "name", toColumnName = "full_name") 
			- @DeleteColumn(tableName = "users", columnName = "temp_field") @RenameTable(fromTableName = "user_data", toTableName = "user_profiles") 
			- class Migration2To3 : AutoMigrationSpec
		- Under the hood, Room auto-migrations rely on the generated database schema, so make sure that the `exportSchema` option in `@Database` is `true` while using `autoMigrations`. Otherwise it leads to an error: `Cannot create auto-migrations when export schema is OFF`.
		- To test auto-migrations, you can use the `MigrationTestHelper` test rule and call `helper.runMigrationsAndValidate()`, in the same way as when using the Migration class.****
		- for table / column delete or rename you’ll have to implement a `AutoMigrationSpec`
	- Need exportSchema:
		1. **Version Control** — Track schema changes in Git
		2. **Migration Testing** — Test migrations against real schemas
		3. **Code Review** — Review schema changes in PRs
		4. **Auto-Migration** — Required for auto-migrations to work
		5. **Documentation** — Clear history of database evolution
3. Room best practice:
	- Always increment version on schema change -> Prevents runtime crash
	- Export schemas to version control -> Track changes, enable testing
	- Test migrations with MigrationTestHelper -> Catch issues before production
	- Use Auto-Migration for simple changes -> Less error-prone
	- Provide defaults for new NOT NULL columns -> SQLite requirement
	- Use table recreation for complex changes -> SQLite ALTER limitations
	- Never use destructive migration in production (unless cache) -> Protects user data
	- Handle foreign keys carefully -> Constraint violations
	- Write idempotent migrations when possible -> Safe to re-run