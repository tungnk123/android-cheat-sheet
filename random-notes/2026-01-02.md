1. # Steve Jobs Used This Method to Think Better & Neuroscience Validates It
	- â€œThe best way to predict the future is to invent it.â€
	- walking
	- Jobs was known for the 10-minute rule: Whenever he was stuck on a problem for more than 10 minutes, he would leave his desk and go for a walk.
	- ## Walking boosts creativity
	- Step 1: analyzing a problem for 10 minutes
	- Step 2: Walk
	- ## Walking together increases the connection between people
	- Research consistently shows that people whoÂ ==move in sync with each other==Â [build stronger connections](https://www.researchgate.net/profile/Michael-Hove/publication/46295417_It%27s_All_in_the_Timing_Interpersonal_Synchrony_Increases_Affiliation/links/02e7e5318af2c23257000000/Its-All-in-the-Timing-Interpersonal-Synchrony-Increases-Affiliation.pdf), even when theyâ€™re not talking.
---
**Use the FIRST message's rules:**

- Battery/Network/Bluetooth/Calls â†’ `@Singleton`
    
- Feature controllers (music player for one screen) â†’ `@ActivityRetainedScoped`
    
- UI helpers â†’ `@ActivityScoped` and below



Hilt/Dagger internally is built on `**javax.inject**`

`jakarta.inject.Inject` creates **a DIFFERENT injection system**

Result: **two parallel object graphs**


Why do you still get **2 instances** even when using `@Singleton`?

1. Constructor injection

class AppBatteryManager @Inject constructor(

private val context: Context

)

2. A `@Provides` method

Hilt now sees **two bindings** for the same type:

- Binding A â†’ via `@Inject constructor`
    
- Binding B â†’ via `@Provides`
    

`@Singleton` works **per binding**

Multiple bindings = multiple singletons

Hilt will NOT warn you

Your bug was **DI configuration**, not Flow, not Battery logic

**Short, concise summary**

- `**@Inject constructor**`
    

Use when **you own the class** and creation is simple.

ğŸ‘‰ Default choice.

- `**@Provides**`
Use when **you cannot modify the class** or **creation needs logic** (builder, condition, factory).
- `**@Binds**`
    

Use **only for interface â†’ implementation mapping**.

ğŸ‘‰ **YES: the implementation MUST have** `**@Inject constructor**`**.**

**Key rules (memorize)**

- **One class = one binding method**
    
- **Never mix** `@Inject constructor` with `@Provides`
    
- `**@Binds**` **does not create objects** â€” it only tells Hilt _which implementation to use_
    

**One-line takeaway**

> **Use** `**@Inject constructor**` **by default,**
> 
> `**@Provides**` **when creation needs logic,**
> 
> **and** `**@Binds**` **only to map an interface to an implementation that already has** `**@Inject constructor**`**.**


- UseÂ **Ktor**Â for networking,Â **SQLDelight**Â for shared DB, andÂ **Kotlinx Serialization**Â for models.
- Good documentation saves future headaches. UseÂ **KDoc**Â (`/** ... */`) for public functions, classes, and modules.
- Use tools like
	- **ktlint**Â â†’ code formatting
	- **detekt**Â â†’ code smells & complexity
	- **SonarQube**Â â†’ maintainability metrics


@JvmInline value class UserId(val id: String)
-> Instead of passing around rawÂ `String`Â IDs everywhere, aÂ `UserId`Â makes your codeÂ **self-documenting**Â and prevents subtle bugs.