Common subclass of RuntimeExceptions:
ArithmeticException: This exception occurs when an arithmetic operation is impossible to perform, like division by zero.
IndexOutOfBoundsException: This exception is thrown to indicate that an index of some sort, such as an array or string is out of range.
=> getOrNull
NoSuchElementException: This exception is thrown when an element that does not exist in a particular collection is accessed. It occurs when using methods that expect a specific element, such as first() or last().
=> firstOrNull, lastOrNull
NumberFormatException: This exception occurs when attempting to convert a string to a numeric type, but the string doesn't have an appropriate format.
=> toIntOrNull, toFloatOrNull
NullPointerException: This exception is thrown when an application attempts to use an object reference that has the null value.
=> handle null safety


The Error subclass represents serious fundamental problems that an application might not be able to recover from by itself. These are problems that you generally would not attempt to handle, such as OutOfMemoryError or StackOverflowError.
The Exception subclass is used for conditions that you might want to handle. Subtypes of the Exception type, such as the RuntimeException and IOException (Input/Output Exception), deal with exceptional events in applications.

 ViewModel uses .first() on Flow → it only collects the first emission (Resource.Loading), so the UI never receives Success or Failure.
 ✅ Fix: use .collect { … } instead of .first() to observe all states.

No — using collect in the ViewModel is correct and expected, not a bug ✅
Here’s why:
 collect listens to all emissions from your Flow (Loading → Success → Failure).
 first() only takes the first value (usually Loading) and then stops — which causes the UI never to update.
So in your case:
mapRepository.searchMosquesNearby(lat, lon).collect { ... }
is the right approach — not a bug.