Optimize app size
	apk -> aab
	WebP
	Clean unused resources
	shrinkResource, miniyEnabled = true
	trim dependencies
		replace heavy libs
		exclude transitive modules
	Use AAB + splits
		abi, density, language
	

How to Disable Screen Inputs on Android Like a Pro
	no panic taps, no double API calls, no spaghetti overlays
	Interface → to say an Activity can be enabled or disabled.
	Extension property → to add a shortcut for isEnabled.
	Functions → how dispatchTouchEvent and dispatchKeyEvent work.
	Compose Screen → crisp example to showcase this gem

	interface UserInteractionConfigurableComponent {
    		var isEnabled: Boolean
	}

	val Activity.userInteractionComponent: UserInteractionConfigurableComponent
    	get() = this as UserInteractionConfigurableComponent

	var Activity.isEnabled: Boolean
    	get() = userInteractionComponent.isEnabled
    	set(value) { userInteractionComponent.isEnabled = value }

	override fun dispatchTouchEvent(ev: MotionEvent?): Boolean {
    		return if (isEnabled) super.dispatchTouchEvent(ev) else true
	}


Fix ANR:	
	Default → for CPU-bound work (sorting, parsing, heavy calculations). Limited threads ≈ CPU cores. Don’t block here.
 	IO → for IO-bound / blocking work (Room DB, network, file access). Larger thread pool, good for blocking.
 	Main → only for UI updates.

	Pitfalls:

 		Blocking (Thread.sleep, drivers) on Default → starves CPU pool.
 		Heavy computation on IO → competes with DB/network threads.
 		flowOn(IO) only moves upstream; operators after it (combine, map, stateIn) still run where you collect.
 		To shift downstream work off Main: use stateIn(scope = viewModelScope + Default) or wrap heavy blocks in 
		withContext(Default).
 		Too many unthrottled jobs (while(isActive) without delay) → CPU storm.
 		Forgetting to cancel old jobs → leaks.


	Rule of thumb:
 		Compute → Default
 		Read/write / wait → IO
 		UI → Main
 		Use withContext to switch properly.
 	For Flow: if you need the whole pipeline off Main, scope it with +Default or move heavy bits with withContext(Default).

Gradle dependency and plugins:
	In Gradle (Android or Kotlin/Java projects), dependencies and plugins are not automatically shared between modules. 
	Each module has its own build.gradle(.kts) file with its own dependencies and plugins block.

	Use Version Catalogs or buildSrc constants.
	Use pluginManagement {
		plugins {}
	}
	Use convention plugin: Plugin<Project>
	Use alias for plugin

listOf, mutableListOf:
	factory function -> return List interface or MutableList interface (interface extending List)
	ArrayList = concrete class, implementation of MutableList using dynamic resizable array	
=> under the hood -> ArrayList
	
	map: LinkedHashMap
	set: LinkedHashSet

-> Why use Linked<Type> as a default type ?
=> 	Stable iteration order -> predictable behavior -> easy Logging, debugging, serialization (JSON, XML).
	Extra memory cost for links is small compared to benefit of predictable iteration.
	
	Insert: LinkedHashMap is only slightly slower (~25% overhead).
	Iterate: basically the same.
	In real Kotlin/JVM, the difference is similarly tiny.

	✅ That’s why Kotlin defaults to LinkedHashMap / LinkedHashSet: you get stable order with almost no cost.



Configuration changes:
	colorMode: The color mode capabilities of the screen (color gamut or dynamic range)
	density
	fontScale, fontWeightAdjustment
	keyboard: when the user plugs in an external keyboard, when the user reveals the hardware keyboard.
	locale: update language
	orientation
	layout direction: left-to-right (LTR) to right-to-left (RTL).
	navigation
	screen layout, screen size: when a different display becomes active 
	touchscreen: when the user connects or disconnects an input peripheral or moves the app between different displays
	uiMode: night mode change