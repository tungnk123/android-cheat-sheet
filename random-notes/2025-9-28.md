Explain Kotlin Flow builders and how you'd use them in a real project
	handling asynchronous data streams
	cold by default
	support backpressure, operators like combine, zip, ...

How do you handle memory leaks in Android applications?	
	1. Context leaks
		Activity reference in static/singleton
		-> use ApplicationContext

	2. Handler/Callback Leaks
		Anonymous inner class holds Activity reference (this)
		-> Static inner class with WeakReference
	
	3. Observer Leaks
		Observer not removed after destroyed
		-> Use Lifecycle-aware observation: viewLifecycleOwner, repeatOnLifecycle, flowWithLifecycle

=> Use LeakCanary in debug builds + Firebase Performance Monitoring in produciton

Explain the difference between launch and async in coroutines
	switching from sequential API calls to concurrent async calls reduced dashboard load time from 3.2 seconds to 1.1 seconds
	Handling partial failures with try catch 

How do you implement proper error handling in Android apps?
	Use try-catch blocks and show error messages to users. -> NOOB 

	-> Use a layered approach with different strategies for different error types:

	1. Network Layer - Structured Error Types
		Use a sealed class NetworkResult: Success, Error, Loading
	2. Repository Layer - Business Logic Errors
		Flow Resource 
		emit(Resource.Loading())
		val cachedUser = cache.getUser(userId)
        	if (cachedUser != null) {
            		emit(Resource.Success(cachedUser))
        	}
		when NetworkResult.Success -> cache.saveUser(result.data); emit(Resource.Success(result.data))
	3. UI Layer - User-friendly Error presentation
		ViewModel:
		Update Ui state with resource + when from Repository
		catch flow from Repository before handle it
	4. Global Error handling
		FirebaseCrashlytics.getInstance().recordException(e)
		 // Restart app gracefully
        	val intent = Intent(context, MainActivity::class.java)
        	intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_NEW_TASK)
        	context.startActivity(intent)
        	Process.killProcess(Process.myPid())

	
Explain Android app architecture and why MVVM is preferred
	testability, maintainability, and scalability

response map theo hướng API→DTO→Domain, request map Domain→DTO→API.
Service layer dùng DTO; Repository trả domain.
	