
---
1. **What happens when user switches from activity A to B**
	- first, `onPause()` of Activity A is called. After that, the system starts creating Activity B: it calls `onCreate()` (where the layout is inflated/Compose content is set), then `onStart()`, and then `onResume()`. 
	- Only once B is ready to be shown to the user and is in the **Resumed** state, the system continues finishing A's transition by calling `onStop()` on Activity A
	- They happen in a clear order where Android ensures UI correctness and smooth transition. (UI thread)
2. Why does user never see empty screen?
	- because of how Android's **WindowManager and rendering pipeline** work during transitions
	- When the switch starts, Activity A's window is still attached to the screen and remains drawn while Activity B is being created and laid out in memory.
	- **A stays on screen while B is being prepared off-screen**
3. How would you implement find view by Id?
	- The `findViewById()` function works by **searching through the view hierarchy tree** to locate a view whose ID matches the one we are looking for.
	- When we inflate a layout, Android builds a **tree of Views**, where each parent view contains child views, and those children may have their own nested children.
	- `findViewById()` simply performs a **recursive or depth-first search** inside this tree until it finds the matching view ID. If the ID matches, it returns that view; if not, it keeps searching through all children. If no match is found, it returns `null`.
4. How to reduce unnecessary recompositions?
	- **Keep state hoisted in ViewModel or parent composables**, rather than storing it deep inside UI components.
	- we should only expose **immutable State, StateFlow, or LiveData**, so that Compose will only recompose when those values actually change.
	- Compose treats data classes as unstable by default unless marked with `@Immutable` or using `@Stable`, ensuring Compose knows the object won't change and avoids extra recompositions.
	- If we need to preserve values across configuration changes, we use `rememberSaveable`. Using `derivedStateOf` also helps when derived computations are expensive but based on stable inputs—so Compose only recomposes when those inputs change, not every time.
5. How is a flow different from channnel?
	- A **Flow** in Kotlin is a **cold, declarative, and reactive data stream**, whereas a **Channel** is a **hot, push-based, coroutine communication primitive**.
	- Flow is designed mainly for **asynchronous data streams like LiveData, API results, database updates, state management, or UI state**, where the data is computed and emitted **only when someone collects it**.
	- **Channel is hot and imperative** — it works like a pipeline or queue for **direct communication between two coroutines**.
	- When one coroutine sends data using `send()`, another coroutine can receive it using `receive()`.
	- Channels behave like **message queues**, useful for producer-consumer, parallel processing, or communicating between coroutines.