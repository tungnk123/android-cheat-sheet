Kotlin coroutine:
	1. The Leaky Network Request
		use the built-in viewModelScope
	2. The Chain Reaction Failure
		use a supervisorScope
		-> a failure of one child does not cause the supervisorScope or its other children to be cancelled
	3. The Sequential async Trap
		The issue is calling .await() immediately after each async call.
		The correct way is to start all async jobs first and then call await() on them afterwards (or awaitAll())
	4. The Replayed Data Stream
		-> StateFlow
	5. the Untestable Delay
		-> runTest and TestDispatcher
	6. The Dispatcher Switch -> withContext
	7. The Callback Conversion
		-> suspendCancellableCoroutine or callbackFlow
	8. The Overwhelmed Collector
		-> conflate(), buffer(), collectLattest()
	9. The Broken Parent-Child Relationship
		-> // Inner coroutine with an independent Job
		viewModelScope.launch {
    			launch(Job() + Dispatchers.IO) {}
		}
	-> The new coroutine is now a "root" coroutine and is not part of the viewModelScope's job hierarchy
	-> cancel parent coroutine does not cancel child coroutine
	=> let it inherit the job
	
	10. The One-Time Event
		-> SharedFlow with replay = 0

StateFlow vs SharedFlow
	Use StateFlow when you need a current state snapshot (UI state, configs, etc.).
	Use SharedFlow(replay = 0) for one-time events (navigation, toasts, messages).
		they only see future emissions
		-> like an event bus (broadcast only)
	Use SharedFlow(replay = 1, onBufferOverflow = DROP_OLDEST) if you want something like StateFlow but donâ€™t want to 
		require an initial value.

	StateFlow is just a specialized, optimized SharedFlow with replay = 1 plus extra guarantees (non-null current value, 
		atomic value updates).