1. MemoryZone thay RAM, ROM
2. 
---
1. Mobile Developer Career in 2030: What Will It Look Like?
	- Whether it’s foldables, wearables, AR glasses, or something implanted (yikes), people will still need apps.
	- Thanks to frameworks like Flutter, React Native, and the rise of AI-assisted code generation, developers in 2030 won’t _just_ target iOS or Android.
	- By 2030, many apps won’t have buttons at all. Instead, they’ll rely on voice, gestures, or eye-tracking.
	- **AI Literacy:** Learn how to leverage, debug, and extend AI-generated code. AI won’t kill your job — it’ll amplify it.
	- **Cross-Platform Thinking:** Stop thinking in terms of “just iOS” or “just Android.” Think ecosystems.
	- **Security & Privacy:** As devices become more personal, protecting user data will be more critical than ever.
	- **Cloud & Backend Knowledge:** Mobile devs who understand APIs, distributed systems, and edge computing will have the upper hand.
2. Stop Writing Massive `when` Statements: Master the State Pattern in Kotlin
	- manage complex objects that change their behavior dramatically based on their internal status
	- The **State Pattern**. And with modern Kotlin, we can implement it with **minimal boilerplate** and maximum elegance.
	- Problem: The core logic is duplicated here based on state
	- Problem: This 'when' block has to be maintained separately
	- ## Phase 1: The Classic State Pattern (Gang of Four)
		- ## 1. Define the State Interface
			- interface MachineState {}
		- ## 2. The Concrete States
			- We implement the behavior for each state. The key takeaway: **all logic for a single state is now in one class/object.**
		- ## 3. The Context (The Machine)
			- class VendingMachineContext
				- var currentState: MachineState = IdleState
	- ## Phase 2: The Enhanced Kotlin-Idiomatic State
		- Kotlin gives us an even more robust and elegant way to structure it using **Sealed Interfaces** to enforce type-safe commands.
		- ## 1. Define All Inputs (Commands)
			- sealed interface VendingInput {  
				data class InsertMoney(val amount: Int) : VendingInput  
				data object SelectProduct : VendingInput  
				data object RequestRefund : VendingInput  
				}
		- ## 2. Define the State and Context
			- A single method handles all possible inputs based on the current state

	- Use the State Pattern when an object’s behavior changes dramatically, and you have conditional logic (`when`, `if/else`) for the state spread across **multiple** methods.
	- if you find yourself writing the same `when(state)` block in `methodA()`, `methodB()`, and `methodC()`, the State Pattern is the right tool.
	- **Why not just use a standard** `**enum class**` **instead of an** `**object**` **for each state?**
		- The **polymorphic** `object`/interface approach scales much better, upholding the Open/Closed Principle. 
		- If you need to add a state or action, you extend (add a new state class) rather than modify (change the central enum file).
3. Jetpack Glance:
	- Widget
4. **Full Context — Concise Technical Summary (End-to-End)**
	- **App scope**
		- Android music app using **Media3 (ExoPlayer + MediaSessionService)**.
		- Foreground playback with notification controls.
		- Single shared player via DI; UI observes state via `StateFlow`.
	- **Core Architecture (What’s correct now)**
	- **Playback lives in** `**MediaSessionService**`, not Activities.
	- **ExoPlayer is attached inside the Service** and shared through a `MusicPlayer` abstraction.
		- UI (Activity/Fragments) only:
		- starts the Service when needed
		- sends playback intents (play, setQueue, next, pause)
		- observes state (isPlaying, buffering, progress, currentTrack).

	- **Critical Lifecycle Rules (Bugs fixed)**
		1. **Service may be killed anytime** (background, memory pressure).
		2. **Every playback entry point must start the Service**:
		- Play/Pause button
		- Tap a track in a list
		- Next/Previous
    

		1. **Never assume the player exists** in ViewModel.
		    
		2. **Queue commands until the player is attached** (command queue pattern).
		    
		3. **Do not call** `**play()**` **blindly**:
		    
		
		- Use `setMediaItems + playWhenReady = true + prepare()`.
		    
		- Calling `play()` with no media item is a NO-OP.
		    
		
		Result:
		
		✅ “First tap doesn’t play” bug fixed
		
		✅ “Sometimes after reopening app it doesn’t play” bug fixed

		**Playback Flow (Final)**
		
		1. UI action → `ensureMusicServiceRunning()`
		    
		2. ViewModel → `setQueue(playlist, index)`
		    
		3. Service `onCreate()`:
		    
		
		- create ExoPlayer
		    
		- `attachPlayer()` → flush pending actions
		    
		
		1. Player prepares → auto-plays (`playWhenReady = true`)
		    
		2. UI updates via `StateFlow`
	    

		**What NOT to do**
		
		- ❌ Start Service on Activity launch
		    
		- ❌ Let ViewModel start/stop Services
		    
		- ❌ Call `play()` before media exists
		    
		- ❌ Rely on timing/delays
		    
		- ❌ Assume Service is always alive
    

		**Notification & Metadata**
		
		- Use `PlayerNotificationManager`.
		    
		- Load artwork asynchronously (cache per mediaId).
		    
		- Metadata must include: title, artist, album, artwork URI.
		    
		- Notification UI is system-controlled (API 33+).
		    

		**Android Auto (Why it matters)**
		
		- Android Auto **uses only** `**MediaSessionService**` (no Activities).
		    
		- If lifecycle is wrong → Auto playback fails.
		    
		- Your current architecture **meets Android Auto requirements**.
		    
		- To publish: manifest config + Auto review (no major code changes).
		    
		
		**Refactor: Required?**
		- **Not required now** (bug fixed, architecture stable).
		- Optional later if you add:
		- widgets, deep links, voice search, Android Auto enhancements.
		
		**Key Takeaways (Write this down)**
		- Playback is **service-driven**, not UI-driven.
		- **Start the Service on every playback intent**.
		- Queue commands until the player exists.
		- `playWhenReady + prepare()` > manual `play()`.
		- Correct lifecycle beats any Media3 “tricks”.
    