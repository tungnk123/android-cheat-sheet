Kotlin DSLs: The Secret Weapon for Writing Elegant Android Code
	Kotlin's DSL capabilities can transform your Android code into readable, type-safe, and maintainable masterpieces.
	A DSL is a mini-language tailored for a particular problem domain

	feature: lambda receivers, extension functions, infix notation, and operator overloading

	Compose is perhaps the biggest success story of DSLs in Android world.

	teams using Compose get a 30% faster UI development cycle than the View-based approach in the past

	Ktor: The Backend DSL

	The main takeaway â€” receivers with lambdas (AnimationBuilder.() -> Unit) This allows you to directly call builder methods 
	without needing explicit references. The secret of every good kotlin dsl.

	DSLs for GraphQL and API Clients

	Truth: DSLs are not slow, that is because of those lambdas.
	Fact: Kotlin compiles inline functions and removes the overhead of lambdas.

	When NOT to Use DSLs:
		Simple operations never make a DSL to call one function
		Learning curve of DSLs (do your developers have any experience with the DSL you intend to use?)
		Over-abstraction: If your DSL requires documentation as long as normal code, you have already lost the battle
		Performance-critical loops Inline DSL can introduce mental overhead even on hot paths

	Best Practices for DSL Design
		1. Reverse engineer the API that you wish you had
		2. Builder should be the exception in favor of immutability
		3. Using @DslMarker to avoid confusion from nested scopes
		4. require() and descriptive exceptions for explicit error messages
		5. Focus that allows DSL to do ONE domain well

You canâ€™t put cornerFamily and cornerSize directly in the style used by ShapeableImageView.
 They belong to a ShapeAppearanceOverlay, not the view style itself.

<com.google.android.material.imageview.ShapeableImageView
    ...
    app:shapeAppearanceOverlay="@style/RoundedImageViewShape" />

=> Use app:shapeAppearanceOverlay for rounded corners â€” not a normal style tag.

If youâ€™re sure youâ€™ll never use the callback â†’ = Unit
 	override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) = Unit
 	If you might add logic later â†’ {}
	=> Explicitly returns Unit

PivotX / PivotY summary (Android rotation):
 	pivotX and pivotY define the rotation or scaling center point of a view.
 	Default pivot = top-left corner (0, 0).
 	To rotate around the center, set:
	view.doOnLayout {
    		view.pivotX = it.width / 2f
    		view.pivotY = it.height / 2f
	}
 	Always set them after layout (inside doOnLayout) so width/height are valid.
 	Example: view.rotation = 45f  // rotates 45Â° around pivot point
 
=> Summary:
 ðŸ‘‰ pivotX = horizontal rotation center
 ðŸ‘‰ pivotY = vertical rotation center
 ðŸ‘‰ rotation = degree of rotation around that pivot

Delegated propertiesï»¿
	delegate their property accessors to another object
	Using delegated properties also reduces boilerplate code because the logic for getting and setting your properties is contained 
	only in the object that you delegate to.

	Every object you delegate to must have a getValue() operator function
	If the property is mutable, it must also have a setValue() operator function for Kotlin to set its value.

	Standard delegatesï»¿:
		If you use one of these delegates, you don't need to define getValue() and setValue() functions because the standard 
		library automatically provides them.

		Lazy propertiesï»¿:
			Lazy interface for delegation
			Lazy properties use the trailing lambda syntax to pass the lambda expression.
		=> Lazy properties are useful not only when initialization is resource-intensive but also when a property might not be 
		used in your code. Additionally, lazy properties are thread-safe by default, which is particularly beneficial if you 
		are working in a concurrent environment.

	Observable propertiesï»¿
		To monitor whether the value of a property changes, use an observable property.
		you want to detect a change in the property value and use this knowledge to trigger a reaction

		var temperature: Double by observable(20.0) { _, old, new -> }