local function vs internal function
	local function = func inside a func
	internal function = func use in same module

Multiple line edit text:
	android:gravity="top|start"
	android:inputType="textMultiLine"
	android:scrollbars="vertical"

type information is erased at runtime (type erasure)
	Because at runtime, the JVM doesn’t know what T really is.
	If you mark T as reified, Kotlin keeps the actual type of T at runtime.
	reified tells the compiler: "Don’t erase the type info, keep it so I can reflect on it."
	You can only use reifiedinside an inline function.
=> inline + reified = more concise and safer API for generics; dont need to pass the class explicitly every time

simpleName vs canonicalName vs packageName vs typeName
	simpleName
		just the class name (MainActivity)
		Usecase: logs, debugs tags
		Unsafe with R8 (can be removed)
	canonicalName
		full name with package name (com.exmaple.MainActivity)
		Use: analytics, crash reporting, screen tracking
		Unsafe with R8 unless you keep name (-keepnames)
	packageName
		package only (com.example)
		Usecase: app id, routing, context info
		Safe with R8
	typeName
		full generic type string (List<String>)
		Usecase: serialization, type-based caching
		Unsafe with R8 unless model class names are preserved

	Best practice:
		avoid relying on runtime class names for IDs or cache keys
		prefer manually defined identifiers
		preserve names in Proguard
			-keepnames class com.yourapp.** { *;}

Android 16 : Important changes for developers
	1. Core Generative AI APIs
		Using a System Text Summarizer

	2. App-Scoped Wi-Fi Access
		Following the pattern of Scoped Storage and Photo Picker, Android 16 might introduce app-scoped Wi-Fi access
		Instead of an app getting a full list of all nearby Wi-Fi networks with the ACCESS_WIFI_STATE permission, it would only 
			see networks it has previously connected to or that are specifically shared by the user.

		<uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
		<uses-permission android:name="android.permission.ACCESS_NEARBY_WIFI_DEVICES" />

	3. Enhanced Lock Screen Widgets & Live Activities
		GlanceableWidgetProvider
		
	4. Finer-Grained Control Over Predictive Back Animations
		A more advanced PredictiveBackHandler might expose the gesture's progress directly.
		PredictiveBackHandler { progress: Flow<Float> -> }
	5. Native Bluetooth LE Audio Broadcast API
		Bluetooth LE Audio, with its "Auracast" feature, allows a single device to broadcast audio to an unlimited number 
		of nearby receivers. 
	=> one-to-many audio streaming

	6. Declarative Workload API for Workload Performance
		Declarative Workload API
		=> your app to explicitly tell the system about the nature of the work it's performing. The OS can then use this 
		information to allocate resources (like CPU cores and frequency) more intelligently, improving battery life without 
		sacrificing performance when it's truly needed.

	7. Ultra HDR for Video
		Android 14 introduced Ultra HDR for images.
		Android 16 will likely add support for capturing and displaying 10-bit HDR video
		=> brighter highlights, deeper shadows, and more vibrant colors without banding
		
		 CamcorderProfile.hasProfile(CamcorderProfile.QUALITY_HIGH_HDR10)
	8. Deeper Health Connect Integration
		Health Connect is becoming a core part of the Android OS instead of just a downloadable app

Declarative Workload API
	Today: Android guesses performance → often inefficient.
	Android 16: Declarative Workload API lets apps tell the system what kind of work they’re doing.
	Benefits: Smarter CPU allocation, better battery life, smoother performance when needed.
	Usage:

		WORKLOAD_TYPE_BACKGROUND → background sync (energy-efficient).
		WORKLOAD_TYPE_UI_INTERACTIVE → real-time UI tasks (high performance).
		Key Action: Identify app “phases” (background vs interactive tasks) and wrap them in workload sessions.

	Use PowerManager.WorkloadRequest to specify:

	Workload Type
		WORKLOAD_TYPE_BACKGROUND → non-urgent, background tasks.
		WORKLOAD_TYPE_UI_INTERACTIVE → real-time, user-facing tasks.
	Hints
		HINT_LOW_LATENCY: True if task is time-sensitive.
		HINT_CPU_INTENSIVE: True if computation-heavy.

