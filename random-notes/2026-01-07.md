1. 8 Room Database Questions That Trip Up Senior Android Devs
	- 1. You need to add a new, non-nullable `last_login_timestamp` column to your `User` table in an app that's already in the wild. How do you write the migration to avoid crashing the app for your existing users?
		- A simple `ALTER TABLE` will fail because existing rows have no value for this new non-nullable column.
		- **By adding `DEFAULT 0`**, you ensure all existing rows get a valid value for the new column, preventing crashes.
	- 2. Your app needs to store `java.util.UUID` in a table, but Room only supports primitive types. What's the clean way to handle this?
		- This question tests your knowledge of **`TypeConverter`**, a simple but powerful feature for telling Room how to handle unsupported types.
		- You create a converter class that tells Room how to convert a `UUID` to a `String` and back.
	- 3. You have `Users` and `Playlists` with a many-to-many relationship. How do you model this and fetch a `User` along with all their `Playlists` in a single query?
		- **@Embedded** val user: User, 
		- **@Relation**( parentColumn = "userId", entityColumn = "playlistId", associateBy = Junction(UserPlaylistCrossRef::class) )
		- **@Transaction**
		- The `@Transaction` annotation is key. It ensures that fetching the `User` and their related `Playlists` happens as a single, atomic operation, preventing inconsistent data states.
	4. You are observing a `Flow<List<User>>` in your ViewModel. How does Room manage to emit updates to this Flow automatically when the `User` table changes?
		- Room uses an **Invalidation Tracker**.
		- The Invalidation Tracker monitors the tables involved in that query.
		- Whenever a write operation (insert, update, delete) affects one of those tables, the tracker gets notified, re-triggers your query, and emits the new result to the `Flow`. 
		- It's efficient because it only re-queries when the underlying data actually changes.
	- 5. Your app needs to ship with a large, pre-populated database of country codes. What is the most efficient way to do this?
		- Loading data from a network call on the first launch is slow and unreliable. Parsing a JSON and inserting thousands of rows one-by-one is also inefficient.
		- The best approach is to provide a pre-packaged database file in your `assets` folder and tell Room to use it.
		- .**createFromAsset**("database/initial_data.db")
		- This is much faster than running thousands of `INSERT` statements. Room will simply copy the database file from your assets into the app's private storage on first install.
	- 6. You're building a search feature for a notes app. How can you implement a fast, full-text search using Room?
		- Using `LIKE '%searchQuery%'` is slow and inefficient on large datasets.
		- Full-Text Search (FTS)
		- You create a special FTS table using `@Fts4` and use the `MATCH` operator in your query.
		- SQLite builds a special index for an FTS table, making text-based searches incredibly fast compared to a standard `LIKE` query.
		- @Entity @Fts4 data class NoteFts( @ColumnInfo(name = "content") val content: String ) @Query("SELECT * FROM NoteFts WHERE content MATCH :query") suspend fun searchNotes(query: String): List<NoteFts/>
	- 7. How would you write an instrumented test for a DAO method? You need to ensure the database state is clean before each test runs.
		- Testing database operations is critical. The key here is to use an i**n-memory database** so your tests are fast and don't affect the real device database.
		- You'd use `Room.inMemoryDatabaseBuilder` and JUnit rules to set up and tear down the database for each test.
	- 8. A user reports that data sometimes disappears. You suspect a race condition between two background threads writing to the database. What tool in Android Studio would you use to investigate this?
		- Use **Database Inspector**
2. **✅ Concise Knowledge Summary (Key Takeaways)**
	**Android / Kotlin / Architecture**
	- `namespace` ≠ `applicationId`; code packages must follow `namespace`
	- Changing `applicationId` requires updating `google-services.json` (per flavor)
	- KSP errors usually come from Hilt / Room / generated code mismatch
	- Always clean build after appId / namespace changes
	**Room**
	- `@PrimaryKey(autoGenerate = true)` → use `id = 0` (recommended)
	- Avoid `id = -1` (logic bugs, DiffUtil issues)
	- Room does not mutate inserted object’s ID
	**Custom View / UI**
	- Complex connected indicators → use image background + overlay icons
	- Simple opacity state → `android:alpha` (0.22f unselected, 1.0f selected)
	- Use magic constants for UI state
	- Custom View exposes callbacks, not navigation logic
	**Indicator Logic**
	- Progress indicator: `index <= selectedIndex` → selected
	- Use callback `(Int) -> Unit` to notify parent
	- Sync ViewPager → indicator via `setStep()`
	**ViewPager Wizard Flow**
	- Single source of truth = `ViewPager.currentItem`
	- `Next`:
	- not last page → `currentItem + 1`
	- last page → call `ViewModel`
	- UI updates via `OnPageChangeCallback`
	**RecyclerView**
	- Auto-scroll → use coroutines + `viewLifecycleOwner.lifecycleScope`
	- Pause auto-scroll when user interacts
	- Cancel job in `onDestroyView`
	**Flow / Coroutines**
	- `combine` must return data
	- `collect` always at end
	- Prefer `repeatOnLifecycle(STARTED)`
	- Avoid reading SharedPreferences directly in UI if Flow exists
	**Best Practices**
	- No hardcoded magic numbers
	- No UI logic in ViewModel
	- No navigation logic in Custom View
	- Lifecycle-aware everything