activityViewModels() vs viewModels(): both are Property delegate functions (Extension functions for Fragment and ComponentActivity)
	viewModels():	
		scope: the current Fragment by default
		each fragments gets its own ViewModel instance
		Fragment is destroyed -> ViewModel is cleared
	activityViewModels():
		scope: the Activity that contains the Fragment
		All Fragments inside the same Activity will get the same instance of that ViewModel
		Useful for sharing state between multiple fragments
	Under the hood:
		1. Find the correct viewModelStoreOwner (Fragment or Activity)
		2. Create or get a ViewModel via ViewModelProvider
		3. Wrap it in a Lazy<T> so it's only created the first time you access it (cached)
	How to communicate between them?
		1. Global stuff (snackbar, logout, theme, user): use AppBus(Repository) (#2) or Fragment mediator (#1).
 		2. Shared flow state across several screens: use shared scope ViewModel (#3).
		3. One-off results: use SavedStateHandle (#4).

The 3 Biggest Coding Mistakes I Made In My Android Projects
	Avoid creating unnecessary centralized chat management classes -> ViewModel + SavedStateHandle
	Understanding process death and in-memory state loss in Android applications.
	Manage UI state correctly to prevent data leakage between user sessions.

Large app sizes can deter users from downloading
	Use Proguard/R8 to shrink and obfuscate code
	Use WebP for images
	Use App Bunbles

App StartupTime
	Optimize code for faster startup
	Use lazy initialization
	Use AppStartup
	Baseline profile

Handling configuration changes:
	orientation
	Dark mode ↔ Light mode (uiMode)
	Language changes (locale)
	Font size changes (fontScale)
	Keyboard show/hide (keyboardHidden)
	Split screen / multi-window mode (screenSize)

Code duplication
	Refactored duplicated code
	Use functions and classes to encapsulate common logic

Lint
	Address Lint warnings
	Configure lint to enforce best practices


lazy
 	Must be val
 	Created automatically on first access
 	Cannot be reassigned
 	Thread-safe by default (LazyThreadSafetyMode.SYNCHRONIZED)
 	Good for one-time initialization when you don’t want to create it until needed
lateinit
 	Must be var
 	You must assign it before use (or crash)
 	Can be reassigned
 	No thread-safety
 	Good when initialization happens later or multiple times
For adapters:
 	Use lazy if it’s created once and used as-is.
 	Use lateinit if it will be assigned or replaced later

Exposed, an ORM framework for Kotlin.
	ORM for server-size or desktop
	Query: Kotlin DSL or DAO
	Multiple DB: PostgreSQL, MySQLm Sqlite, ...

	When to use:
		Server-side Kotlin (Ktor, Spring Boot) — works with PostgreSQL, MySQL, SQLite, etc.
		Want type-safe SQL via Kotlin DSL (compile-time checks).
		Need multi-database support.
		Prefer clear transaction control and batch operations.
		Want to mix DSL + raw SQL when needed.
	Avoid if:
		Android offline storage (Room fits better)
		Only need SQlite + LiveData/Flow integration
		Want Google's Android best practices & built-in mitigrations

ORM = Object Relational Mapping = A technique to interact with db using objects and OOP methods instead of raw SQL
	Map DB tables <-> classes
	Handle SQL generation, data mapping, and type safety
