
- Ctrl + arrow -> quick move cursor
- Win + Alt + arrow -> navigate tabs in chrome
- **5 Coffee Habits That Instantly Make You More Productive Than 99% of People**
	- 1. Delay Your First Cup by 60–90 Minutes
		- **Wait until cortisol drops**, typically **60–90 minutes** into the morning. (NO ONE KNOWS)
		- Use the first 60–90 minutes for hydration, sunlight, and planning. Then enjoy your first cup when your brain is primed to use it.
	- 2. Pair Coffee With 10 Minutes of Morning Sunlight
		- Drink your first cup after a brief dose of outdoor light.
		- Executives often report that **sunlight + coffee produces "cleaner" focus** and reduces the jittery, anxious edge caffeine can produce on its own.
	- 3. Use the "Hydrate-Caffeinate" Rule
		- Drink a full glass of water before your first cup and another afterward.
		- **The formula:**
			- 12 oz water
			- Coffee
			- 12 oz water
		- This keeps your nervous system calm, your brain hydrated, and your energy steady.
	4. Use Micro-Dosing Instead of Mega-Dosing
		- Instead of one giant coffee, break your caffeine into two or three smaller "micro-doses."
		- This is how Navy SEALs, pilots, and elite executives maintain focus for long durations — controlled, consistent caffeine instead of spikes.
	5. Create a "Coffee + Deep Work Trigger" Ritual
		- Pair your first or second coffee with the start of a deep work session.
		- **Why it works:** Your brain builds **environmental associations**. If coffee becomes the cue for deep work, your focus increases before caffeine even hits your bloodstream.
		- Within weeks, your brain associates: **coffee = focus mode**
- iosArm64 vs appleMain
---
1. Why do we use `withContext` inside suspend functions? Can we directly use Dispatchers in `launch`?
	- `withContext` switches the coroutine context (like thread or dispatcher) _for a specific block_ without creating a new coroutine.
	- Keeps the suspend function reusable, testable, and doesn't create unnecessary new coroutines.
	- `launch` starts a new coroutine (fire-and-forget).
	- `withContext` just suspends the current one until finished.
2. **`runBlocking`****:
	- Blocks the current thread until the coroutine completes.
	- Use **only in main functions or tests**, never in production UI code.
3. What's the difference between `launchWhenStarted`, `launchWhenResumed`, and `repeatOnLifecycle` in Android?
	- **`launchWhenStarted`** **and** **`launchWhenResumed`****:
		- Old lifecycle-aware coroutine builders.
		- Run when lifecycle reaches the specified state and _pause_ when it's below.
		- But they can miss emissions while inactive.
		- **The Risk:** If you were collecting a flow of data, your flow might have kept buffering "old" events while you were paused. When you resume, you might suddenly process a bunch of outdated updates all at once.
	- **`repeatOnLifecycle`****:
		- Launches a new block each time lifecycle enters a state, and cancels when leaving.
		- Prevents leaks and ensures emissions aren't missed.
		- **The Benefit:** You never process "stale" data. You always start fresh with the latest state (e.g., fetching the current UI state immediately).
	- **`launchWhenStarted`** = **Resumes** (Good for one-shot tasks that _must_ finish eventually, but bad for observing data streams).
	- **`repeatOnLifecycle`** = **Restarts** (The safest standard for UI data observations).
	- **Best practice:** Always prefer `repeatOnLifecycle` now.
4. What is `flowOn` and how is it different from `withContext`?
	- `flowOn` changes the context _upstream_ of Flow emissions
	- `withContext` changes the context inside a `suspend` block
	- **`withContext`****:
		- Works inside suspend functions.
		- Switches thread for that specific block.
	- **`flowOn`****:
		- Works on the Flow chain.
		- Moves upstream operators to another dispatcher.

5. What happens if you collect Flow on Main thread without using proper dispatcher?
	- If your Flow performs blocking operations (like reading from a database, making a network request, or complex calculations) and you collect it on the Main thread without `flowOn`, **you will freeze the app.**
	- By default, a Kotlin Flow is **synchronous** and **context-preserving**. This means the code inside the `flow { ... }` builder runs in the **same thread** that calls `.collect()`.
	- If you call `collect` from the `Main` thread (e.g., inside a `lifecycleScope` or `ViewModel`), the **entire chain** upstream (the repository, the data source) attempts to run on the `Main` thread.
	- The `.flowOn(Dispatchers.IO)` operator acts as a **context switch boundary**. It decouples the _producer_ (upstream) from the _consumer_ (downstream).
		- **Upstream (Above `flowOn`):** Runs on the background thread (IO).
		- **Downstream (Below `flowOn`):** Runs on the collector's thread (Main).
	- flow { emit(1) // Runs on IO } 
		.map { it * 2 } // Runs on IO 
		.flowOn(Dispatchers.IO) // <--- The Switch 
		.map { it.toString() } // Runs on Main (or whatever scope called collect) 
		.collect { ... }
	- Best practice:
		- Apply `.flowOn(Dispatchers.IO)` or `Default` at the end of the chain in Repository
		- Launch in `viewModelScope` (Main). Do not change dispatchers here.
		- **NEVER** use `withContext` _inside_ a `flow { ... }` builder to wrap `emit()`. **(Violate Context Preservation)** => use `flowOn()`
		- **Is it a `Flow`?** -> Use `.flowOn(Dispatchers.IO)`
		- **Is it a `suspend fun`?** -> Use `withContext(Dispatchers.IO)`
		- If you need to do heavy work _after_ receiving data, you can use `withContext`, but it's usually better to handle heavy work in the flow pipeline (upstream) before collecting.
6. How to use SwiftUI in a KMP project?
	- expect @Composable
	- NativeViewFactory
	- Xcode
	- build framework -> add to xcode search path