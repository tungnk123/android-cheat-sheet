Fix ANR:	
	Default → for CPU-bound work (sorting, parsing, heavy calculations). Limited threads ≈ CPU cores. Don’t block here.
 	IO → for IO-bound / blocking work (Room DB, network, file access). Larger thread pool, good for blocking.
 	Main → only for UI updates.

	Pitfalls:

 		Blocking (Thread.sleep, drivers) on Default → starves CPU pool.
 		Heavy computation on IO → competes with DB/network threads.
 		flowOn(IO) only moves upstream; operators after it (combine, map, stateIn) still run where you collect.
 		To shift downstream work off Main: use stateIn(scope = viewModelScope + Default) or wrap heavy blocks in 
		withContext(Default).
 		Too many unthrottled jobs (while(isActive) without delay) → CPU storm.
 		Forgetting to cancel old jobs → leaks.


	Rule of thumb:
 		Compute → Default
 		Read/write / wait → IO
 		UI → Main
 		Use withContext to switch properly.
 	For Flow: if you need the whole pipeline off Main, scope it with +Default or move heavy bits with withContext(Default).

Gradle dependency and plugins:
	In Gradle (Android or Kotlin/Java projects), dependencies and plugins are not automatically shared between modules. 
	Each module has its own build.gradle(.kts) file with its own dependencies and plugins block.

	Use Version Catalogs or buildSrc constants.
	Use pluginManagement {
		plugins {}
	}
	Use convention plugin: Plugin<Project>
	Use alias for plugin

Configuration changes:
	colorMode: The color mode capabilities of the screen (color gamut or dynamic range)
	density
	fontScale, fontWeightAdjustment
	keyboard: when the user plugs in an external keyboard, when the user reveals the hardware keyboard.
	locale: update language
	orientation
	layout direction: left-to-right (LTR) to right-to-left (RTL).
	navigation
	screen layout, screen size: when a different display becomes active 
	touchscreen: when the user connects or disconnects an input peripheral or moves the app between different displays
	uiMode: night mode change

ViewModel:
	Never store a UI controller or Context directly or indirectly in a ViewModel.
	Direct or indirect references to UI controllers defeat the purpose of separating the UI from the data and can lead to 
		memory leaks

listOf, mutableListOf:
	factory function -> return List interface or MutableList interface (interface extending List)
	ArrayList = concrete class, implementation of MutableList using dynamic resizable array	
=> under the hood -> ArrayList
	
	map: LinkedHashMap
	set: LinkedHashSet

-> Why use Linked<Type> as a default type ?
=> 	Stable iteration order -> predictable behavior -> easy Logging, debugging, serialization (JSON, XML).
	Extra memory cost for links is small compared to benefit of predictable iteration.
	
	Insert: LinkedHashMap is only slightly slower (~25% overhead).
	Iterate: basically the same.
	In real Kotlin/JVM, the difference is similarly tiny.

	✅ That’s why Kotlin defaults to LinkedHashMap / LinkedHashSet: you get stable order with almost no cost.