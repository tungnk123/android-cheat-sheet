fun twoSum(nums: IntArray, target: Int): IntArray {
        val map = HashMap<Int, Int>()
        for (i in nums.indices) {
            val temp = target - nums[i]
            if (map.containsKey(temp)) {
                return intArrayOf(map.getOrDefault(temp, 0), i)
            }
            map[nums[i]] = i
        }
        return intArrayOf(-1, -1)
    }


mapOf() → immutable Map → ❌ can’t do map[key] = value.
HashMap() → mutable MutableMap → ✅ supports set/get.
mutableMapOf() → idiomatic Kotlin factory for MutableMap → ✅ same as HashMap, but preferred.
	A shorthand factory for a LinkedHashMap<K, V> (which implements MutableMap<K, V>).
	Equivalent to HashMap<Int, Int>() in your case, but with insertion-order iteration.
👉 Use mutableMapOf in Kotlin unless you specifically need a HashMap.

List is an immutable interface. To “update” a list inside a data class, you shouldn’t mutate the old list. 

Why use `plus()`?
	Prevents accidental mutations of the original list.
	Always produces a new list → safe for UI state (Compose, MVI/MVVM).
	Cleaner and more concise compared to using `toMutableList().apply { add(...) }`.
		Instead, use the + operator (plus()), which creates a new list with the additional element(s).