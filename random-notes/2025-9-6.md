fun twoSum(nums: IntArray, target: Int): IntArray {
        val map = HashMap<Int, Int>()
        for (i in nums.indices) {
            val temp = target - nums[i]
            if (map.containsKey(temp)) {
                return intArrayOf(map.getOrDefault(temp, 0), i)
            }
            map[nums[i]] = i
        }
        return intArrayOf(-1, -1)
    }


mapOf() â†’ immutable Map â†’ âŒ canâ€™t do map[key] = value.
HashMap() â†’ mutable MutableMap â†’ âœ… supports set/get.
mutableMapOf() â†’ idiomatic Kotlin factory for MutableMap â†’ âœ… same as HashMap, but preferred.
	A shorthand factory for a LinkedHashMap<K, V> (which implements MutableMap<K, V>).
	Equivalent to HashMap<Int, Int>() in your case, but with insertion-order iteration.
ğŸ‘‰ Use mutableMapOf in Kotlin unless you specifically need a HashMap.

List is an immutable interface. To â€œupdateâ€ a list inside a data class, you shouldnâ€™t mutate the old list. 

Why use `plus()`?
	Prevents accidental mutations of the original list.
	Always produces a new list â†’ safe for UI state (Compose, MVI/MVVM).
	Cleaner and more concise compared to using `toMutableList().apply { add(...) }`.
		Instead, use the + operator (plus()), which creates a new list with the additional element(s).