1. > ❓ _If a new observer subscribes later, should it receive the last value immediately?_
	- **YES** → State
	- **NO** → Event
	- Events: Toast / Snackbar, navigation, Websocket frame, chat message, error event, permission request, analytics log 
	- State: Loading flag, Current user, current data, playback state
2. **Room / Database**
	- `@Insert` can return **auto-generated ID**
	- Use `suspend fun insert(): Long`
	- Returned ID = rowId
	- `OnConflictStrategy.REPLACE` may change IDs
3. **namespace vs applicationId**
	- **✅ Code package → MUST follow** `namespace`
	- **❌ Code package → MUST NOT follow** `applicationId
	- KSP processors (Hilt, Room, Moshi) **only care about namespace**, not applicationId.
	- `namespace` = compile-time package (R, BuildConfig, KSP)
	- `applicationId` = runtime identity (Play Store, Firebase)
	 - Kotlin package structure MUST follow `namespace`	
	- Hilt / Room / KSP ignore applicationId
	- google-services.json MUST match applicationId
	- Mixing package structures causes silent KSP crashes
4. You're building a chat app. You need to subscribe to a `Flow` of incoming messages from a repository. This subscription is expensive (e.g., opens a WebSocket). How can you share this single subscription across multiple collectors (e.g., a message list and a notification badge) so the connection is only active when there's at least one active collector?
	- This is a resource management problem. We need to convert a cold flow into a hot `SharedFlow` that is aware of its collectors and can manage the underlying expensive resource.
5. The fragment currently visible → **RESUMED** Any fragment kept alive by offscreenPageLimit but not visible → **STARTED**
6. withContext vs launch vs async
	- **Late-initialized properties and variables**
	dependency injection or inside the setup method of a unit test
	For class properties:
	- You can't declare them in the primary constructor.
	- They must not have a custom getter or setter.
	In all cases, the property or variable must be non-nullable and must not be a [primitive type](https://kotlinlang.org/docs/basic-types.html)
	- `launch([Dispatchers.IO](http://Dispatchers.IO))`: starts a new coroutine on the IO pool, returns a `Job`, no result.
	- `withContext([Dispatchers.IO](http://Dispatchers.IO))`: suspends the current coroutine, runs the block on IO, returns the block’s result.
	- `async([Dispatchers.IO](http://Dispatchers.IO))`: starts a new coroutine that returns a `Deferred<T>`; you get the result via `await()` (structured way to do concurrency).
	**When to use**
	- `**launch(IO)**`: fire-and-forget background work where you don’t need a value back.
	- `**withContext(IO)**`: you need to do IO within a suspend flow and return a value, then resume on the original context.
	- `**async(IO)**`: you want to kick off concurrent tasks that each produce a value and later await them (possibly in parallel).
	Concurrency
	- `**launch(IO)**`: Runs independently
	- `**withContext(IO)**`: Inline, sequential within caller
	- `**async(IO)**`: Can run many in parallel; await later
	Fire-and-forget on IO => launch
	**Compute on IO and return value (sequential): withContext**
	Parallel requests, then combine: async
	Use `coroutineScope { ... }` (or a structured scope like `viewModelScope`) around multiple `async` calls so they cancel together.
	**Quick rule of thumb**
	- Need a value now → `withContext(IO)`
	- Need to do it in parallel and then combine → `async(IO)` + `await()`
	- Need to just kick off background work tied to a scope → `launch(IO)`