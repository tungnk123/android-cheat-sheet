Use Cursor.use {} instread of closeCursor 
	-> better, clean code

	Exception-safe: always closes, adds close() errors as suppressed exceptions if needed.
	Fewer leaks: harder to forget closing.
 	Cleaner code: no boilerplate try/finally.
 	Null-safe pattern: handler?.query(..)?.use { c -> ... } does nothing if null.
	
	it calls close() even if an exception is thrown, preventing leaks (CursorWindow/FD leaks can lead to OOM/ANR)
	Better exception handling: if close() also throws, that exception is added as a suppressed exception rather than masking 
		the original one.
Refactored tips:
	Early returns > nested ifs: flatten control flow.
	One-liners for trivial logic: e.g., exists() checks, getters.
	String templates & File(base, child): avoid brittle string concat.
	Remove !!; guard nulls and return early (handler ?: return …)
	Keep computations inside use {} blocks (don’t leak closed resources).
	Prefer Kotlin stdlib utilities:
 		use {} for Cursor/streams (auto-close, safer than manual finally).
 		walkTopDown() for size calc.
 		deleteRecursively() / copyRecursively() for tree ops.
	No braces needed if the if has one statement -> early return

Kotlin Flow Interview
	suspend function: oneshot async result
	flow: multiple async values over time
	LiveData: UI-centric hot observable
		
	flatMapConcat vs flatMapMerge vs flatMapLattest
