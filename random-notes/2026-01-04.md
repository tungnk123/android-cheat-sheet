1. Namecheap DNS with vercel config
2. 
---
1. If I Had to Start iOS Development in 2026, Here’s Exactly What I’d Do
	- I Would Skip UIKit Entirely (And Not Feel Guilty) -> **Learn SwiftUI from day one**
	- I’d Learn Swift Like a Language, Not a Tool -> Learn deep knowledge
		- value vs reference semantics
		- copy-on-write behavior
		- ARC and retain cycles (still relevant, sorry)
		- `async/await` and structured concurrency
		- actors and isolation
		- result builders (the core of SwiftUI)
	- I’d Learn SwiftUI the Way Apple Intended, Not the Way YouTube Teaches It
	- Choose MVVM as architecture
	- I’d Stop Calling Myself a “Mobile-Only” Developer, learn
		- **REST beyond “GET and POST”
		- authentication flows
		- pagination strategies
		- retry logic and rate limits
		- offline-first design
		- sync conflicts**
	- I’d Learn Debugging Before I Felt “Ready”
2. MVVM Clean Architecture in Android
	- View 
	- Domain layer:
		- Contains core business logic
		- Most inner layer (independent of everything)
		- Represents "what" the app does
		- Pure Kotlin code with ZERO Android dependencies
		- Contains: Entities, Usecases, repository interface
		- **Depends on**: Nothing (completely independent)
		- **Framework dependent**: No (pure Kotlin)
		- **Should NOT contain**: Android imports, UI logic, data source details
		- **Should contain**: Business rules, validation logic, calculations
	- Data layer:
		- Components include Repository Implementations, Data Sources (Remote and Local), Data Transfer Objects (DTOs), and Mappers.
3. Android Development Best Practices
	- Detect and Fix **memory leaks** in Android App
	- Use **Proguard** in your release version
	- Use **shapes** and **selectors** instead of images as much as possible -> reduce apk size
	- Avoid deep levels in layouts -> **ConstraintLayout**
	- Use the Parcelable class instead of Serializable when passing data in Intents or Bundles
	- Understand Bitmaps
		- They also consume a lot of memory. A lot of memory!.
		- By using the **Bitmap pool**, they avoid continuous allocation and deallocation of memory in our application and reduce GC overhead.
		- **Bitmap pooling is an implementation that tries to reuse the memory of the bitmaps already available instead of allocating new memory every time.**
		- When these libraries have to load the new bitmap, they just get a bitmap that can be reused to load the new one to reuse the same memory from that bitmap pool. Hence no recycling, and no GC calls.
	- Always include unit tests
	- Optimize your build speed
	- Secure your Android Application
	- Add Analytics, Crashlytic to Your Android Application