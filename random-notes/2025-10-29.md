Decompose — experiments with Kotlin Multiplatform lifecycle-aware components and navigation
	Multiplatform: Android, iOS and JavaScript
	Encapsulation of business logic into lifecycle-aware components (aka BLoCs)
	Nested components
	Routing (or navigation) between components
	Components’ state preservation (including back stack)
	Instances retaining in components (aka ViewModels in Android)
	Pluggable platform-specific UI (primarily declarative UI frameworks, such as Jetpack Compose, SwiftUI, JavaScript React, etc.)

	Decompose provides Value and MutableValue interfaces and their builders and extensions for exposing state from components.

	In Decompose routing functionality is provided by the Router.
		interface Router<C : Parcelable, out T : Any> {
    			val state: Value<RouterState<C, T>>
    			fun push(configuration: C)
    			fun pop()
		}

	the Router is just a stack of components.
	push and pop

	State and back stack preservation when configuration changes or process is recreated

	ComponentContext
		In Decompose every component has a ComponentContext. It is nothing more than an interface that gives 			components access to some features, like the Lifecycle.



Throw exceptions with precondition functions﻿: require, check, error

The finally block is always executed, but it doesn't change the result of the try-catch block.

In Kotlin, the idiomatic way to manage resources that implement the AutoClosable interface, such as file streams like FileInputStream or FileOutputStream, is to use the .use() function.

In Kotlin, every expression has a type. The type of the expression throw IllegalArgumentException() is Nothing
Nothing is a special type in Kotlin used to represent functions or expressions that never complete successfully, either because they always throw an exception or enter an endless execution path like an infinite loop.
Kotlin's TODO() function, which also uses the Nothing type, serves as a placeholder to highlight areas of the code that need future implementation
The TODO() function always throws a NotImplementedError exception.

Common subclass of RuntimeExceptions:
	ArithmeticException: This exception occurs when an arithmetic operation is impossible to perform, like division by zero.
	IndexOutOfBoundsException: This exception is thrown to indicate that an index of some sort, such as an array or string is out of range.
=> getOrNull
	NoSuchElementException: This exception is thrown when an element that does not exist in a particular collection is accessed. It occurs when using methods that expect a specific element, such as first() or last().
=> firstOrNull, lastOrNull
	NumberFormatException: This exception occurs when attempting to convert a string to a numeric type, but the string doesn't have an appropriate format.
=> toIntOrNull, toFloatOrNull
	NullPointerException: This exception is thrown when an application attempts to use an object reference that has the null value.
=> handle null safety

The Error subclass represents serious fundamental problems that an application might not be able to recover from by itself. 	These are problems that you generally would not attempt to handle, such as OutOfMemoryError or StackOverflowError.

The Exception subclass is used for conditions that you might want to handle. Subtypes of the Exception type, such as the RuntimeException and IOException (Input/Output Exception), deal with exceptional events in applications.

The stack trace is a report generated by the runtime environment, used for debugging. It shows the sequence of function calls leading to a specific point in the program, especially where an error or exception occurred.