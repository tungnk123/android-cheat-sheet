1. **How We Reduced Android App Crashes by 95%**
	- Crashes aren't just annoying — they cost users transactions and us revenue.
	- **Fix 1: Crash-Proof Null Safety**
		- **Early null checks with user-facing messages**: Instead of crashing, show helpful error messages that guide users to fix the issue.
		- **Logging for every null case**: Each null path logs an event. This told us why users had incomplete data and let us fix the root cause.
		- **Sealed UI state**: No way for the UI to enter an invalid state.
	- **Fix 2: Network Request Crash-Proofing**
		- We created a Result wrapper and defensive parsing
		- sealed class ApiResult: Success, Error, NetworkError
			- Success: 200 + response.body != null
				- Check if code = 401 -> ApiResult.Error
				- Check if code = 500 -> ApiResult.Error
			- catch JsonParseException
			- catch IOException: network error
			- catch Exception
		- **Catch every possible exception**: JSON parsing, network failures, unexpected errors.
		- **Never return null**: Always return a valid Result type.
		- Use a **Resource** sealed class also
	- **Fix 3: Lifecycle-Aware Coroutines**
		- We were updating UI after the Fragment was destroyed. This caused 18% of our crashes.
		- `viewLifecycleOwner.lifecycleScope`
		- `viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED)`
	- **Fix 4: RecyclerView Index Out of Bounds**
		- The Fix: **DiffUtil** + **Immutable** Lists
	- **Fix 5: Memory Leaks Causing Out of Memory Crashes**
		- **LruCache** with size limit
		- **Lifecycle** awareness: Cancel downloads when view is destroyed.
		- Or use **Coil**/**Glide**: Battle-tested libraries handle all edge cases.
	- **Fix 6: Thread Confinement Violations**
		- Classic mistake: updating UI from a background thread.
		- Use `withContext`, `Dispatcher` properly
	- **Fix 7: SQL Injection and Database Crashes**
		- Use ROOM
		- Room handles parameterization automatically. No more SQL injection, no more crashes from special characters.
	- **Fix 8: Configuration Change Crashes**
		- Communication through ViewModels survives configuration changes without crashes.
		- Use activityViewModels and viewModels() delegate
	- **Fix 9: Use StrictMode to catch issues in development before they reach production.**


2. **Master Kotlin Multiplatform with Decompose — Part 3: Restoring state with InstanceKeeper and StateKeeper**
	- Retaining state during configuration changes: [**InstanceKeeper**](https://arkivanov.github.io/Decompose/component/instance-retaining/), similar to [**ViewModel**](https://developer.android.com/topic/libraries/architecture/viewmodel) from [**Android Jetpack**](https://developer.android.com/jetpack).
	- Recovering state after process death:  [**StateKeeper**](https://arkivanov.github.io/Decompose/component/state-preservation/) provided by Decompose serves as a solution, similar to **onSaveInstanceState** or **SavedStateHandle**.
	  
	  
3. Get current time in KMP
	- System.currentTimeMillis(): JVM-only
	- Clock.System.now(): KMP, need @OptIn(ExperimentalTime::class)
	- getTimeMillis(): KMP, no Optin, Faster, simple, pure millisecond timestamp
	- 