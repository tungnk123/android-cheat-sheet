ProcessLifecycleOwner
	onStop -> clear cache after delay
	onStart -> stop it

onTrimMemory
	happens when process deaths happens
	memory is low -> OS will clear data

stopForeground deprecated:
	stopForeground(removeNotification: Boolean)
	-> New method in Android 12 (API 31):
	stopForeground(behavior: Int)

	Service.STOP_FOREGROUND_REMOVE: remove the notification
	Service.STOP_FOREGROUND_DETACH: keep the notification

Android Security Tips: Must read for android developers
	WebView Security: Taming the Web
		Disable JavaScript Unless Absolutely Necessary
			webView.settings.apply {
    				// Only enable if you absolutely need it and trust the content
    				javaScriptEnabled = false
    
    				// Prevent file access
    				allowFileAccess = false
    				allowContentAccess = false
			}
		Use HTML Message Channels for Secure Communication instead of direct Javascript interface

	API Key Management: Secrets in the Shadows
		Use Build-Time Secret Management
		-> BuildConfig

		Implement Certificate Pinning for Critical APIs

	Input Validation: Trust No One
		validate user input
		sanitizeForDatabase

	Cryptography: Use the Experts’ Work
		Android Keystore
		Cipher

	Monitoring and Maintenance: Stay Vigilant
		-> Firebase, Log, ...

Bridge pattern:
	I was building a video player that needed to support multiple themes (e.g., Light and Dark) and playback engines 
	(e.g., FFmpeg and Native OS)

	With two themes and two engines, I had four classes.
	I faced 3 themes × 3 engines = 9 classes

	I realized themes (UI) and engines (playback) are separate concerns
	The Bridge pattern decouples these, letting them vary independently. 
	It connects two hierarchies:
		Abstraction: The user-facing player with themes. (interface)
		Implementation: The backend playback engines. (abstract class)


Polymorphism:
	overload: compile time
	override: runtime