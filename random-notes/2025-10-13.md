Room will ignore whatever value you pass (including 0, or null for nullable keys) and replace it with an auto-generated ID when 
	inserting a new entity.

callbackFlow with awaitClose -> 
awaitClose { removeTextChangedListener(listener) }

Avoid Using !! in Kotlin — Safer Alternatives for Null Handling
	Kotlin also provides the not-null assertion operator !!, which can convert any nullable value into a non-null type

	The !! operator effectively bypasses Kotlin’s type system. It silences compiler warnings by saying “I know better than the 
		compiler.”

	Alternative 1: Safe Call with Fallback: ?., orEmpty(), and Elvis ?:

	Alternative 2: Explicit Null Check with if
		Business logic must branch depending on nullability.
		You want full control over both null and non-null cases.

	Alternative 3: Fail Fast with requireNotNull and Custom Messages
		Use requireNotNull only in cases where null truly indicates a programming error (for example, invalid state or 
		 incorrect API usage).
	Alternative 4: Concise Null-Safe Blocks with let
		You want to perform an action only when the value is non-null.
=> Use ?. with orEmpty() or Elvis ?: for fallback values.
Use explicit if checks when business logic depends on nullability.
Use requireNotNull for programmer errors, with a clear failure message.
Use let for concise null-safe blocks. 



Primary constructor
Property initializer
init block with declaration order
secondary constructor
-> Parent constructor → Parent init → Child property → Child init → Child secondary

Update svg icon color
	setColorFilter(iconInt)

Shadow for text :
	shadowColor
	shadowDx
	shadowDy	
	shadowRadius = blur
	
	textView.setShadowLayer(radius, x, y, color)

final vs open in Koltin: defaule for every class is `final`

data class = equals() + hashcode + toString + copy + destructuring

Inline value classes
	Issue: create small objects from classes and use them only briefly
	-> performance impact 

	@JvmInline
	value class Email

	An inline value class must have a single property initialized in the class header.
	=> you make the class inlined and can use it directly in your code without creating an object. This can significantly reduce 
	memory footprint and improve your code's runtime performance.

	Must have exactly one property (the underlying value).
	data of the class is inlined into its usages (similar to how content of inline functions is inlined to call sites).

=> create a type-safe wrapper around a primitive or simple value, without runtime overhead.

	Meters(5.0) vs Seconds(5.0) — both are Double underneath,
	but it’s a logic bug if you add a distance to a duration.

	Value classes make such bugs impossible at compile time.


When to use inline value class:
	You have a single primitive value that represents a distinct domain concept
	→ e.g. UserId, ProductId, Email, Meters, Money, etc.
	You want type safety (can’t mix up IDs or units).
	You want zero runtime cost — it’s inlined, no object allocation.

Extension properties﻿
	Extension properties allow you to add new properties to existing classes without modifying their source code

	extension properties in Kotlin do not have backing fields -> you need to write the get() and set() functions yourself.
		
	val String.lastChar: Char
	