Activity: onStop() -> onRestart() -> onStart() -> onResume()
Fragment: onDestroyView() -> onCreateView() -> onViewCreated() -> onStart() -> onResume()

repeatOnLifeCycle: only run with view lifecycle instead of fragment lifecycle
	Usecase: start or stop a coroutine block automatically based on the lifecycle state of a component
	(merge coroutine block with the lifecycle)

	It only run the block when the lifecycle is at least in a certain state (STARTED, RESUMED) and cancels it when it 
	drops below that state - then restarts it again if it returns

	Prevent memory leaks, prevent ui updates on destroyed views, prevent manual lifecycle handling
	

Chain Of Responsibility in Android
	A well-known example you've probably used without realizing it is the Interceptor chain in OkHttp. 
	Each interceptor is a link in a chain that can inspect, modify, or handle a network request before passing it to 
		the next link.
	
	Fix giant if-else block in your code
	Example:
		AuthenticationHandler() -> LoggingHandler() -> SavingHandler()
	=> flexible, decoupled, follows the SRP 

I Reviewed 100 Android Codebases — Here’s What Most Developers Get Wrong
	1). Overengineering the Architecture
		Keep things simple until they need to scale.
		Only introduce abstractions with a real use case.
		Prefer readability over “purity.”

	2). Poor Lifecycle Handling	
		Always scope coroutines to the correct lifecycle owner.
		Use tools like LeakCanary and StrictMode.
		Understand how lifecycle events work across Activity, Fragment, and ViewModel.

	3). Too Much Logic in the UI Layer
		Keep your composables lean.
		Push logic to the ViewModel or use MVI-style unidirectional data flow.
		Use UI state classes to encapsulate logic cleanly.

	4). Ignoring Jetpack Best Practices
		Stay updated with Jetpack’s recommended libraries.
		Don’t ignore the tooling Google gives you — it’s designed for scale and stability.
		Embrace Kotlin Flows, Jetpack Compose, and Hilt responsibly.

	5). Not Considering Security at All
		Store secrets in the NDK or use encrypted SharedPreferences.
		Use ProGuard/R8 rules for obfuscation.
		Validate inputs server-side and client-side.

	6). App Startup Is an Afterthought
		Defer initialization with WorkManager, App Startup, or lazy loading.
		Use tools like Startup Profiler, Baseline Profiles, and Systrace.

	7). No Consistent Code Review Guidelines
		Adopt tools like Ktlint and Detekt.
		Create a short, documented code review checklist.
		Use GitHub Actions or CI tools to enforce quality.