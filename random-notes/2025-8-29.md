Functional programming vs OOP
	FP: multiple state, update UI, concurrency, testing, easy logic, ...
	OOP: UI components, entity, property, ...

Functional programming in depth:
	FP = pure functions + immutable data
	Pure functions:  (no hidden side effects).
	Immutability: (data never changes, only new versions are created).
	Composition:  (build larger logic from small functions).
	Side-effect isolation: (I/O, network, DB pushed to the edges).

Kotlin Best Practices Every Android Developer Should Know in 2025
	If you’re still writing XML layouts, you’re not just behind — you’re actively handicapping your team’s velocity

	Compose Bill of Materials (BOM)

	State pattern:
		when (val state = userState) {
        		is UserState.Loading -> LoadingIndicator()
        		is UserState.Success -> UserContent(state.user)
        		is UserState.Error -> ErrorMessage(state.message)
    		}

	BasicText(
		autoSize = TextAutoSize.StepBased(
            		minFontSize = 12.sp,
            		maxFontSize = 24.sp,
            		stepSize = 2.sp
        	)
	)

	In Kotlin, consider using Hilt for dependency injection.

	Unit testing with JUnit and Mockito

Clean Architecture:
	"Clean Architecture is a software design philosophy created by Robert Martin that organizes code into concentric circles, 
	where dependencies always point inward toward the business logic

	Presentation Layer (outer) — UI components like Activities, Fragments, and ViewModels
	Domain Layer (middle) — Business logic, use cases, and entity definitions
	Data Layer (inner) — Data sources, repositories, and external APIs

	Domain layer depends on nothing (pure business logic)
	Data layer depends only on Domain layer
	Presentation layer depends on both Domain and Data layers

	"Use Cases represent specific business actions your application can perform. 
	They orchestrate data flow between entities and enforce business rules. 
	Repositories, on the other hand, abstract data access and provide a clean API for data operations."