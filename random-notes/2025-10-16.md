Q1: What is the purpose of suspendCancellableCoroutine and when would you use it?
	suspendCancellableCoroutine is used to convert callback-based APIs into suspend functions that work with coroutines. 
	It creates a bridge between the callback world and coroutine world.

	Converting legacy callback APIs to coroutines
	Working with third-party libraries that only provide callbacks
	Wrapping platform APIs that use callbacks

Q2: What's the difference between suspendCoroutine and suspendCancellableCoroutine?
	suspendCoroutine: Basic version, doesn't support cancellation
	suspendCancellableCoroutine: Supports cancellation and is the preferred choice

=> Best practice: Always use suspendCancellableCoroutine in production, Cancellable version allows cleanup via invokeOnCancellation

Q3: How do you handle errors when converting callbacks to coroutines?
	Use continuation.resumeWithException() to convert callback errors into coroutine exceptions. This allows natural exception 	
	handling with try-catch blocks.

	
Q4: What happens if you don't call resume or resumeWithException in a suspendCancellableCoroutine block?
	The coroutine will hang indefinitely (suspend forever) because it's waiting for the continuation to be resumed. This is a common 
	source of bugs.

Q6: What is invokeOnCancellation and why is it important?
	invokeOnCancellation is called when the coroutine is cancelled. It's crucial for cleaning up resources like network calls, file 
	operations, or timers.

	Why it's important:
		Prevents resource leaks
		Cancels ongoing operations
		Maintains app performance

Q8: What are the performance benefits of converting callbacks to coroutines?
	Reduced memory overhead: No callback objects stored in memory
	Better thread utilization: Coroutines are lighter than threads
	Elimination of callback hell: Reduces nested object creation
	Structured concurrency: Better resource management and cancellation

Q9: How do you handle multiple callback operations concurrently using coroutines?
	Answer: Use async and await to run converted suspend functions concurrently.

Q10: What are common pitfalls when converting callbacks to coroutines?
	Not handling all callback cases: Missing else conditions
	Calling resume multiple times: Will crash the app
	Forgetting cancellation handling: Resource leaks
	Thread safety issues: Callbacks might be on different threads
	Not using suspendCancellableCoroutine: Missing cancellation support

suspend fun getData() = suspendCancellableCoroutine { continuation ->
    val call = service.fetch { data, error ->
        when {
            data != null -> continuation.resume(data)
            error != null -> continuation.resumeWithException(Exception(error.message))
            else -> continuation.resumeWithException(Exception("Unknown error"))
        }
    }
    
    continuation.invokeOnCancellation {
        call.cancel()
    }
}

Prefer using an expression body for functions with the body consisting of a single expression.

Libraries and APIS
	 Libraries expose APIs as a set of functions, classes or properties that developers can use in their code