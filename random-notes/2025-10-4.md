StateFlow vs SharedFlow
	StateFlow represents "What is the current situation?"
	SharedFlow represents "What just happened?"

	StateFlow:
		- Always holds a current value
		- New collectors immediately receive the latest state
		- Conflates values (only latest value matters)
		- Replay = 1 by default
		- Use for: UI states, configuration, current selections

	SharedFlow:
		- No initial value
		- Configurable replay and buffering
		- No conflation by default (all values are delivered)
		- Use for: One-time events, notifications, navigation actions

=> StateFlow = SharedFlow(replay = 1) + initial value + conflate + atomic update

clear separation between state and events
	private val _uiState = MutableStateFlow(LoginUiState())
    	val uiState: StateFlow<LoginUiState> = _uiState.asStateFlow()
    	private val _events = MutableSharedFlow<LoginEvent>()
    	val events: SharedFlow<LoginEvent> = _events.asSharedFlow()

	data class LoginUiState(
    		val isLoading: Boolean = false,
    		val username: String = "",
		val isLoginEnabled: Boolean = false,
    	val error: String? = null
	)
	// Events for one-time actions
	sealed class LoginEvent {
    		object NavigateToHome : LoginEvent()
    		data class ShowError(val message: String) : LoginEvent()
    		object ShowLoginSuccess : LoginEvent()
	}

SharedFlow: New collectors receive nothing initially unless you configure replay > 0. 
=> They only get values emitted after they start collecting.

StateFlow handles configuration changes gracefully because new collectors get the current state. 
SharedFlow with replay=0 prevents events from re-triggering after rotation

Test -> Always use runTest from kotlinx-coroutines-test
StateFlow conflation() -> SharedFlow
