1. 7 Advanced Kotlin Patterns You Should Know
	- 1. Sealed Classes for Safer State Management
		- Your `when` expressions must handle every case, enforced at compile time. The result: predictable, bug-resistant state management.
	- 2. Delegated Properties for Smarter Fields
		- by lazy, by viewmodels
	- 3. Type Aliases for Cleaner Signatures
		- typealias OnUserClickListener = (User, Int) -> Unit
		- It costs nothing at runtime but pays dividends in clarity.
	- 4. Value Classes for Type Safety
		- Relying on raw `String` or `Int` types for IDs, emails, or tokens is a recipe for bugs.
		- @JvmInline value class UserId(val value: String)
		- @JvmInline value class Email(val value: String)
		- The compiler enforces correctness, preventing entire classes of errors.
	- 5. Operator Overloading for Expressive DSLs
		- This makes your domain logic read the way it should. It's also the foundation for elegant DSLs like Jetpack Compose or Ktor.
	- 6. Inline Functions with Reified Types
		- Generics normally suffer from type erasure. Kotlin's inline functions with reified parameters give you access to type information at runtime.
	- 7. Coroutines with Structured Concurrency
		- scoping coroutines to lifecycles (like `viewModelScope`), you avoid leaks and orphaned jobs
2. Linux:
	- it refers only to the **operating system kernel**: the basic program that underlies everything else that communicates with the **hardware** (such as CPU, memory and attached devices) and the **applications** that run on the computer.
	- Linux distributions (Linux distro): integrate all components like applications, libraries, graphic environments, ...
	- ![[Linux distros.png]]
	- multi-boot installations
	- 100GB unallocated free space
	- _Linux was inspired by UNIX, but it is not UNIX._
	- Kernel = glue between hardware and applications
	- Distro = a collection of programs combined with the Linux kernel to make a Linux-based operating system
	- Boot loader = program that boots the OS, exmaple: GRUB, ISOLINUX
	- Service = program that runs as a background process
	- Desktop environment = graphical UI on top of OS, exmaple: GNOME, KDE, FluxBox, ...
	- Command line vs Shell: Shell = command line interpreter that interprets the command line input and instruct os to perform tasks
	- Linux distro = linux kernel + software tools: file, user, software package management
	- ## Boot process
		- Power ON
		- BIOS or EFI/UEFI (on ROM memory): init hardware: screen, keyboard, RAM, ...
		- Boot loader: GRUB, loading the kernel image and the initial RAM disk or filesystem
		- The boot loader loads both the **kernel** and an initial RAM–based file system (initramfs) into memory, so it can be used directly by the kernel.
		- Kernel: et up all its hardware and mounted the root filesystem
	- ## Linux Filesystem
		- A partition is a  dedicated subsection of physical storage media.
		- Linux: /dev/sda1/
		- Type: EXT3/EXT4/XFS/BTRFS...
		- Base folder (where OS is stored): / 
		- Filesystem Hierarchy Standard (FHS)
		- All Linux filesystem names are case-sensitive, so **/boot**, **/Boot**, and **/BOOT** represent three different directories (or folders).
	- A **partition** is a logical part of the disk.
	- A **filesystem** is a method of storing/finding files on a hard disk.A partition is a logical part of the disk.
	- A filesystem is a method of storing/finding files on a hard disk.
	- ## Desktop environment
		- Dekstop Manager -> GUI
		- GNOME desktop environment:
			- 