
---
1. Code review:
	- catch for flow
	- @Keep
2. Coroutines & Flows: 5 Critical Anti-Patterns That Are Secretly Slowing Down Your Android App
	- **The Main Thread Trap: Heavy Work in `viewModelScope`**
		- If your coroutine contains heavy computation, such as complex data mapping, filtering massive lists, or complex business logic, you are effectively freezing the UI, even though you think you’re “on a coroutine.”
		- Best Practice: Use `Dispatchers.Default` for CPU Work
	- **The Premature Cancellation Trap (Navigation Race)**
		- The `ViewModel` should be the one to signal the UI that the operation is complete.
		- For tasks that _must_ finish (e.g., logging, crash reporting, background sync) even if the UI is gone, use a custom, application-scoped `CoroutineScope`.
	- Anti-Pattern Example (Wasted Time)
		- ANTI-PATTERN: Immediate join forces sequential execution.
	- Launch all the independent tasks first to get them running concurrently, and only then call `join()` or `await()` to wait for the results.
	- Best Practice: Never Catch Cancellation (or Re-throw It)
		- This 'eats' the signal, the coroutine is never fully canceled,  // and the 'while(true)' loop re-runs immediately.