Primary keys in room: NOT NULL

Google Play keystore (.jks): Used to sign your app for release.

Android Keystore (API): Used to secure sensitive data at runtime inside the userâ€™s device.

Hashing vs Encryption
	one way vs 2 way
	verify intergrity vs protect confidentiality
	SHA-256 vs AES, RSA

	Hashing:
		password storage
		file integrity
		cache keys
	Encryption:
		secure communication (HTTPs)
		store sensitive data (tokens, credit cards)
		encrypted local databases

	SHA-256: input 512 bits, output 256 bits (HEX, Base64)
	
	 Best Practice:
		Use UTF-8
		Must match server format (Base64 or Hex)
		Hashing on background thread
		Usually encoding/charset
		Use canonical string -> unique

	SHA256, SHA512, BLAKE3 -> too fast -> brute force
	-> PBKDF2, scrypt, Argon2 -> slow, memory hard

	salt + pepper in hash

1. The App Died. Now What?
	When the user returns, they expect their form data to still be there. How do you use a ViewModel to solve this, and what 
	specific component is essential?
	
	This is a classic process death scenario. A standard ViewModel alone won't save you because it's destroyed with the process. 
	The key is to use the SavedStateHandle

	You need to inject SavedStateHandle into your ViewModel's constructor. This object is a key-value map that survives process 
	death and is tied to the ViewModel. You can use it to save and restore the UI state.

2. The Shared ViewModel Problem
	activityViewModels() + viewModels()

3. The Runaway Network Call
	use viewModelScope

4. The Parameterized ViewModel
	=> Custom ViewModelFactory
5. The Untestable ViewModel 	
	Testing a ViewModel with coroutines and LiveData requires a specific test setup
6. The Final Cleanup
	The one and only place to do this is in the onCleared() method of the ViewModel.
	This method is called right before the ViewModel is destroyed, for instance, when its associated Activity or Fragment is 
		finished and destroyed permanently.

Room + Coroutine (DAO + Dispatcher Rules)
	suspend func, fun ...: Flow<> -> Dont need Dispatcher.IO
	fun ...: T (non-suspend) -> run synchronously -> muse use WithContext(Dispatcher.IO)

Room DAO method return type summary:
	@Insert: 
		void/Unit
		Long: row id of the inserted row
		List<Long>: row ids for multiple inserts
	@Update:
		void/Unit
		int: number of rows updated
	@Delete:
		void/Unit
		int: number of rows deleted
	@Query:
		Entity, List<Entity>, Flow, LiveDataCursor 