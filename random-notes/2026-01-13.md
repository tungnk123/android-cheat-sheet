- git reflog
- retry and withTimeOut in coroutine
- fedora shortcuts:
	- Super + L -> Lock screen
	- 
---
1. Hilt Scope:
	- `**@HiltViewModel**` **defines the ViewModel**
	- `**@ViewModelScoped**` **defines objects owned by that ViewModel**
	- Is this a helper / use case used by the ViewModel? -> ViewModelScoped

	- Do NOT scope UseCases. Keep UseCases:
		- stateless		    
		- thin
		- cheap to create
	- Use `@ViewModelScoped`**only when a dependency must live exactly as long as a ViewModel and be shared inside it**.
	 - `@ViewModelScoped` is for **stateful, lifecycle-bound helpers owned by a ViewModel**, not for every UseCase.
	 - `@Singleton` (Application scope)
		- Retrofit / OkHttp
		- Room Database
		- TokenManager / UserSession
		- Analytics
	- `@ActivityScoped` (Activity scope)
		- Multiple fragments in the same activity share logic
		- NavigationManager
		- Shared UI events (toast, dialog)
		-  Activity-level state
	- `@FragmentScoped` (Fragment scope)
		- Logic belongs to one fragment only
		- FormValidator
		- UI helpers
		- Adapter factories
	- `@HiltViewModel` (Screen logic)
		- Managing screen state and business logic
	- `@ViewModelScoped` (Inside ViewModel)
		- A dependency must be shared **inside** one ViewModel
		- Checkout price calculator
		- Order validation logic
		- Multi-step flow coordinator
	- `@ServiceScoped` (Service lifecycle)
		- Background work tied to a Service
		- UploadManager
		- Background sync helper
2. Stop the `if-else` Madness! A Better Way to Handle Plurals in Kotlin for Android
	- you need to display text that changes based on a count
	- you might reach for a clumsy `if-else` or `when` block in your Kotlin code, checking if the count is 1 or not, and manually switching strings.
	- **String resources with plurals**.
	- plurals name="egg_count">  
		item quantity="one">I have %d egg./item>  
		item quantity="other">I have %d eggs./item>  
		/plurals>
	- res.getQuantityString
	- **Don’t write another** `**if (count == 1)**` **block! Embrace the** `**<plurals>**` **tag and write professional, clean, and globally-aware Kotlin code for Android.**
3. runInterruptible
	- use withContext under the hood
	- when the coroutine is cancelled, `[runInterruptible] calls `Thread.interrupt()` on that thread. Most blocking APIs such as file I/O, sockets, or JDBC stop early when interrupted.
	- Use `runInterruptible` when calling **blocking APIs** that don’t have suspend versions and may take time to finish.
	- `withContext` moves work to another thread.  
	- `runInterruptible` moves it and makes it stoppable.
	- withContext
		- Does **NOT** interrupt blocking Java calls
		- Cancellation is checked only at suspension points
		- Blocking calls keep running until finished
	- `**runInterruptible**`
		- Makes blocking code **interruptible**
		- On coroutine cancel → **interrupts the thread**
		- Registers a cancellation handler
		- Calls `Thread.interrupt()` on cancel
		- Converts `InterruptedException` → `CancellationException`
	- **Why** `**runInterruptible**` **exists**
		Blocking Java APIs **ignore coroutine cancellation**:
		- `Thread.sleep`
		- `BlockingQueue.take`
		- `Socket.read`
		- JDBC
		- File I/O (some APIs)
	- `runInterruptible` **bridges coroutines ↔ Java threads** safely.
	- Coroutines cancel cooperatively.
	- Threads cancel preemptively.
	- `runInterruptible` is the bridge — use it only when needed. (Java, legacy)
	- **Raw JDBC / SQLiteOpenHelper, java.io.File -> runInterruptible**

4. Security Crypto — Effortless Data Encryption
	- **Jetpack Security Crypto** handles encryption for we, no need to reinvent AES logic or key management.
	- EncryptedSharedPreferences
	- **Perfect for:** Storing tokens, user credentials, or sensitive settings securely — in just a few lines.
5. Accompanist — The Missing Jetpack Compose Toolbox
	- It provides extensions for animations, insets, permissions, and more that the Compose team hasn't added (yet).
	- Ready-to-use animations and utilities.
	- Simplifies common Compose edge cases.
	- Constantly updated alongside Compose releases.