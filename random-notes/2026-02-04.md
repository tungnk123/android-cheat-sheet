
1. **small apps with the right users outperform large apps with the wrong ones**.
	_Revenue now comes from value, not volume._
	**In 2026, niche wins.**
	**Step 1: Choose a Painful, Specific Problem**	
	- Profitable apps solve **one clear problem**.
	**Step 2: Validate Before You Build**
	**Step 3: Pick a Monetization Model Early**
	- Subscription
	- One-time purchase
	**Step 4: Build a Small, Strong MVP**
	**Step 5: Design for Retention, Not Downloads**
	**Retention Features That Work in 2026**
	- Smart reminders
	- Usage streaks
	- Saved history
	- Progress tracking
	- Cloud sync
	**Step 6: Onboarding Is Everything**
	**Step 7: Build Trust Before Asking for Money**
	Ask for payment **after users feel benefit**, not before.
---
1. Kotlin multiplatform with Kotlin 2.3
	- Where KMP really stands out is the sharing of business logic
	- ViewModels, repositories, networking layers, and data mapping
	- **Ktor has mature production-ready features for networking and data layers**.
	- Apollo Kotlin integration works perfectly with GraphQL. Excellent support for gRPC if you are building backend services to be used with your apps.
	- MUST KNOW BOTH IOS AND ANDROID
2. Kotlin Coroutine Cancellation Explained: Strategies, Pitfalls, and Real-World Failures
	- Coroutines areÂ **cooperative**, not preemptive.
	- When a job is cancelled:
		- The coroutineÂ **does not stop immediately**
		- ONlY update the state machine
		- It stops only atÂ **cancellation points**
	- **Cancellation points include:**Â ðŸš¨
		- Suspending functions (delay, withContext, await, collect)
		- Manual Checks (isActive, ensureActive)
	- **Dont Swallowing CancellationException**
		- Coroutine is cancelled
		- CancellationException is thrown
		- You catch it and ignore it
		- Coroutine keeps running
3. Dependency Injection with Hilt
	- @AndroidEntryPoint: create a dependency container for that class
	- @HiltAndroidApp: create a dependency container for application
	- Hilt components: Singleton, Activity, ActivityRetained, Fragment, Service, ViewModel, View, ...
	- 2 type of bindings:
		- Unscoped bindings: available in all components if not installed in a Module
		- Scoped bindings: scoped to one component and inherited by subcomponents
	- Hilt: by viewModels(), @HiltViewModel, @AndroidEntryPoint, viewModels()
	- Hilt Gradle Plugin:
		- Bytecode rewriting for @AndroidEntryPoint
		- Classpath aggregation
	- @Installin -> tell components and scope
	- 
4. Hilt Testing best practices:
	- Hilt tesing is build around using real objects and avoiding mocks
	- @HiltTestApplication, @HiltAndroidtest, @TestInstallIn, @UninstallModule
5. Hilt extensions:
	- Hilt extension = code generatation tool that contribute modules or entry point into Hilt
	- @HiltWorker
	- Hilt aggregation classpath:
		- Aggregations of modules and entry points is done across the classpath