
---
1. **Explore Android | Material3 Color Schemes And Material Design Components**
	- **There are total 5 types of key colors:  
		1. Primary Color: colorPrimary, colorOnPrimary, colorPrimaryContainer, colorOnPrimaryContainer
		2. Secondary Color  
		3. Tertiary Color  
		4. Neutral Color  
		5. Neutral Variant Color
	- Types:
		- color
		- surface:
		- container
	- **Usecase**:
		- Screen background: `background, onBackground`
		- Cards / Sheets: `surface`, `onSurface`, `surfaceVariant`
		- Primary buttons: `primary`, `onPrimary`, `primaryContainer`
		- Secondary buttons: `secondary`, `onSecondary`
		- Text / icons: `onSurface`, `onSurfaceVariant`
		- Warnings / errors: `error`, `onError`, `errorContainer`
		- Dividers / borders: `outline`, `outlineVariant`
	- ![[MaterialTheme-Button.png]]
	- ![[MaterialTheme-Chíp.png]]


2. **MVVM Anti-Patterns: 7 Mistakes That Make Your Android Codebase Hard to Maintain**
	- **The God ViewModel**
		- **Fix it:** Keep ViewModels dumb. They should orchestrate, not execute. Push logic down into **use-case classes** or **repositories**. A good heuristic: if a function doesn't depend on the UI state, it probably belongs elsewhere.
	- **Mutable State Leaks**
		- This allows any part of your UI to modify internal state, leading to random, non-reproducible bugs.
	- **Treating Events as State**
		- Toasts, navigation, and one-off alerts are not persistent state. Yet many developers store them in the same flow or LiveData as UI state. 
		- This creates **stale events** that re-emit on rotation or recomposition.
		- **Fix it:** Separate **state** (something that can be restored) from **events** (something that happens once). Use `SharedFlow` or a one-time channel for events, and a `StateFlow` for persistent state.
	- **Bloated Repositories**
		- **Fix it:** Keep repositories focused on data access (network, DB, cache). Push transformation or business logic to **use-case** classes.
	- **Ignoring Coroutine Contexts**
		- Launching everything in `viewModelScope.launch` without specifying context is a silent performance killer. You end up running I/O operations on the main thread.
		- Structured concurrency doesn't save you from wrong contexts; **explicit context switching** does.
	- **Over-Engineering Data Flows**
		- **Fix it:** Start simple. Use the least reactive tool that solves the problem.
		- Reserve complex Flow chains for truly dynamic screens.
	- **No Architectural Boundaries**
		- **Fix it:** Combine MVVM with **Clean Architecture principles**. Introduce clear boundaries:
			- **Presentation layer:** View + ViewModel
			- **Domain layer:** Use cases, pure logic
			- **Data layer:** Repositories, network, persistence 