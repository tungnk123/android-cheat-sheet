commit() vs commitAllowingStateLoss():
	IllegalStateException: Can not perform this action after onSaveInstanceState

	When app destroy an recreate the Activity to save resources -> Call onSaveInstanceState()
	=> app save your current state => Activity is condidered state-saved
	=> If u try to change the UI by committing a FragmentTransaction after this moment -> IllegalStateException
	Why ?
	-> The new fragment wont be part of the saved state -> weird, unpreditable UI -> Crash
	
	Use commit() 99% of the time -> structure your app so that u only commit fragment transactions when your activity
		is in a safe state (before onSaveInstanceState)

	commitAllowingStateLoss():
		skip the safety check and execute the transaction
		=> no crash, but you face a new subtle bug
	=> just use when u dont need the loss fragment -> LoadingFragment, Toast, LoggingFragment

	The modern solutuon: Think Lifecycles
		Use lifecycle components, perform the transaction only when its lifecycle is in a safe state (like RUSUMED)

		Use LiveData or StateFlow with repeatOnLifecycle
		-> show fragments -> safe way

	Alternative solution
		1. check lifecycle manually: lifecycle.currentState.isAtLeast(Lifecycle.State.STARTED)
		2. use fragment's commitNow(): synchronous execution, immediate transactions

	Best Practices:
		always prefer commit() - safe default
		use lifecycle-aware components
		check lifecycle state before commiting transactions
		reserve commitAllowingStateLoss() for non-critical UI
		test rotation scenario
