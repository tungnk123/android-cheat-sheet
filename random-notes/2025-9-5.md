Multithreading is a must-have, but the improved performance comes at a cost:
    - increased complexity
    - increased memory consumption: Threads come with an overhead in terms of memory and processor usage
    - nondeterministic order of execution that the application has to manage.
    - Data inconsistency â†’ Race condition
=> Atomic region, mutually exclusive or synchronized block
Critial regions must be executed atomically by one thread at a time
=> Lock mechanism

synchronized vs ReentrantLock vs ReentrantReadWriteLock
	they both block all threads trying to execute a critical section if another thread has already entered that region.

	The ReentrantReadWriteLock lets reading threads execute concurrently but still blocks
	readers versus writers and writers versus other writers

Kotlin Flow:
	Flow isn't just a reactive tool. it's a powerful, declarative, coroutine-based mindset.

Android Design Pattern:
	Singleton:
		Global shared instances (when used with care)
		ensure a class has only one instance, and provide a global point of access to it

	Facade pattern:
		Complex subsystems leaking into UI or business logic
		-> Simplify with a single, unified interface (Facade)
		I needed to create a single, simple interface to hide all the ugly implementation details

		class DataExportFacade(
    			private val userService: UserService,
    			private val csvWriter: CsvWriter,
    			private val pdfGenerator: PdfGenerator,
    			private val zipArchiver: ZipArchiver
		)
	=> Simplify Complex Workflows, Decouple the Client