Keep passwords out of source code — why and how
	Embedded credentials, also often referred to as hardcoded credentials, are plain text credentials in source code.
	
	password vs credentials or secrets
	credential = secret = password + API Keys + certificates + SSH keys

	How to store your credentials
	-> Injecting credentials into a container: AWS, Azure, GCP or Heroku

	Credential provider
	Build Pipelines:
	-> handle secrets in build pipelines
	
StateFlow:
	there are two ways to change a MutableStateFlow:
		Directly assigning with .value = ...
		-> direct way, simple, change the value

		Using .update { ... }
		-> your next state depends on the previous state.
	=> For multi-threaded cases, .update { } is safer because it avoids race conditions.

	tryEmit() is a normal function, not a suspending function.
	Use .tryEmit() when you’re in a context where suspending is not allowed (like from a callback), but still want to update 
	the flow. For StateFlow, it’s almost the same as .value.
	=> use tryEmit for SharedFlow

Map vs HashMap vs HashTable vs ConcurrentHashMap
	Not synchronized (default): HashMap, LinkedHashMap, TreeMap, plain Map, MutableMap.
	Synchronized: Hashtable (old, global lock), Collections.synchronizedMap (global lock), ConcurrentHashMap (modern, efficient).
	Buckets are used in HashMap and ConcurrentHashMap to handle hash collisions.
	Race conditions are handled by synchronization (locks/CAS), not by buckets.

deadlock solution:
	Always acquire locks in one global order (e.g., A → B everywhere).
	Or collapse to one lock, or use ReentrantLock.tryLock with timeouts.
	Prefer coroutine Mutex over synchronized.
	Keep critical sections tiny; do not call into UI or external services while holding locks.
	Add timeouts around anything that could stall.
