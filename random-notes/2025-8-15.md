Start making your Android app more secure today
	Avoid storing sensitive data like tokens or Personally Identifiable Information (PII) on device.
	If you absolutely must, since EncryptedSharedPreferences is deprecated, consider Android KeyStore and DataStore.

	Make use of Keystore-backed storage for custom encryption of files, blobs, or streams
	Android Keystore will store your cryptographic keys securely, keys you use to encrypt/decrypt sensitive data, which you 
		store elsewhere, like in DataStore, Room, or even a file.
	
	For transient data, prefer in-memory caching rather than writing to disk.
	Avoid memory leaks: Leaked contexts or long-lived references can inadvertently expose sensitive data in memory. 
	Use tools like LeakCanary to detect and fix them.

Volatile vs Atomic variables vs synchronized vs Mutex vs Flow
	Volatile: 
		Ensures visibility: when one thread changes the value of a volatile variable, other threads immediately see the updated value.
		Does not guarantee atomic compound operations.
		Usecase: simple read/write flags
	Atomic variables
		Provide atomic operations (read, write, increment, compare-and-set) without explicit locks.
		Thread-safe for individual operations.
		Usecase: For counters, flags, or references where you need lock-free atomic updates.
	synchronized
		Guarantees mutual exclusion and visibility.
		Slower than atomic variables for very frequent operations, but much easier to reason about when multiple operations must be done together.
		Usecase: multiple operations
	Mutex:
		For suspending functions in Kotlin coroutines, use Mutex for mutual exclusion without blocking threads
		Usecase: multiple operations in coroutine
	Flow
		Internally handle thread safety and value propagation.
	Great for Android UI state rather than raw atomic primitives.

=> conclusions
	@Volatile: only visibility, not atomic for compound ops like count++, directly access
 	Atomic*: visibility + atomic for single operations; check-then-set access
 	synchronized / Mutex: full mutual exclusion for multi-step logic.
 	For Kotlin coroutines, prefer Mutex over blocking locks.

WifiLock: Allows an application to keep the Wi-Fi radio awake
	Before using a WifiLock, consider carefully if your application requires Wi-Fi access, or could function over a mobile network,
	must request the android.permission.WAKE_LOCK permission
=> needs to download large files to ensure download is complete; but a program whose network usage is occasional or low-bandwidth 
	should not hold a WifiLock to avoid adversely affecting battery life.