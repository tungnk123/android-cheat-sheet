1. The UI Update Race
	2 coroutine access a shared object -> race condition
	-> ensure state updates are atomic: use update {} or Mutex to lock

2. The Leaky Network Call
	Dont use GlobalScope -> Structured concurrency: viewModelScope, lifecycleScope
	
3. The Deadlocked Repository
	syncUserData() acquires a lock on userCacheLock and then settingsCacheLock. 
	syncSettings() acquires a lock on settingsCacheLock and then userCacheLock

4. Migrating RxJava's zip Operator
	The zip operator in RxJava runs two streams in parallel and combines their results when both have emitted an item.
	=> use async + await() in a CoroutineScope -> ensure structured concurrency

5. From Callback Hell to suspend Heaven
	Convert the callback-based functions into suspend functions with suspendCancellableCoroutine
	Let you write sequential-looking code that is actually asynchronous under the hood

6. The Saturated I/O Dispatcher
	An app performs hundreds of small, fast file read operations and a few slow network calls. 
	All are launched on Dispatchers.IO
	=> slow network 
	Dispatchers.IO is backed by a shared thread pool with a default limit (typically 64 threads). 
	When you saturate it with hundreds of tasks, new tasks have to wait.

	Create a custom dispatcher with its own dedicated thread pool for the file I/O operations.	
	val fileIODispatcher: CoroutineDispatcher = Executors.newFixedThreadPool(4).asCoroutineDispatcher()

7. The Concurrent Cache Problem
	Manage access to this cache to ensure thread safety while maximizing performance
	-> ConcurrentHashMap (CAS, bucket), not Mutex or synchoronized

	Multiple threads can read from the map simultaneously without blocking.
	Multiple threads can even write to different parts of the map simultaneously.

JAR â†’ Use for pure Java logic (e.g., math utils, JSON parsers, networking libraries).
AAR â†’ Use for Android components (views, UI widgets, libraries with resources/manifests/native libs).

NDK (Native Development Kit) = Googleâ€™s toolkit for building Android apps with C/C++.
 	Lets you compile C/C++ into .so libraries (native code).
 	Used for performance-critical tasks (video, audio, AI, games) or reusing existing C/C++ libs (FFmpeg, OpenCV).
 	Works with JNI so Kotlin/Java can call native code.
 	Supports multiple ABIs (arm64-v8a, x86_64, â€¦).
 	Important now: NDK r28+ builds .so with 16KB alignment required for Android 15+.
ðŸ‘‰ In short: NDK = toolchain for compiling and integrating native C/C++ into Android apps.

	JNI (Java Native Interface) =. A bridge that lets Java/Kotlin code call C/C++ functions, and vice versa.
	ABI (Application Binary Interface) =. Defines how machine code runs on a CPU architecture: instruction set, registers, 
		calling conventions, etc.
		On Android, common ABIs are:
 			armeabi-v7a â†’ 32-bit ARM
 			arm64-v8a â†’ 64-bit ARM (most modern devices)
 			x86_64 â†’ 64-bit Intel/AMD
 	You must compile .so separately for each ABI you want to support.
=> 	NDK compiles your C/C++ into .so files per ABI.
 	JNI is the glue that lets your Kotlin/Java code call into those .so files.
	LTS = Long-Term Support =. built on an older FFmpeg baseline + config that is kept stable, and supports older Android devices (minSdk 16)