Understanding callbackFlow vs. suspendCoroutine in Kotlin Coroutines
	Callbacks have been the lifeblood of asynchronous programming for decades. However, they can get messy — nested callbacks 
	(a.k.a. callback hell), complex error handling, and resource leaks are just a few of their pitfalls. 

	Kotlin Coroutines aim to fix this by allowing you to write asynchronous code as if it were synchronous.

	Think of suspendCoroutine as a bridge for one-time asynchronous tasks. It transforms a callback-based operation that produces a 
		single result into a suspending function.

	The coroutine pauses execution at suspendCoroutine.
	A continuation is created and passed into your block.
	When the callback completes, you use the continuation to resume the coroutine with the result (or an exception).


	If suspendCoroutine is for single results, callbackFlow is for continuous streams of data. It lets you convert APIs that emit 
		values repeatedly into a cold Flow.
	callbackFlow creates a flow, but the real action begins only when someone starts collecting.
	Inside the callbackFlow, you register a callback and start emitting values to the flow.
	When the flow is canceled, you clean up with awaitClose.
	
	Use suspendCoroutine when:
		You’re working with one-time results.
		The API triggers its callback exactly once.
		You want to integrate such an API into a coroutine’s suspendable flow.\

	Use callbackFlow when:
		You’re working with continuous data streams.
		The API triggers callbacks multiple times over time.
		You want to emit values as a Flow with lifecycle-aware cancellation.

	=> Single event? Go with suspendCoroutine.
	Multiple events? Choose callbackFlow.

Dagger, Hilt: compile time DI
Koin: runtime DI

== vs === vs equals:
	== -> call equals()
	equals(): referenrial equality by default (for Any object) -> class comparision is false
	
	data class -> override equals() + hashCode() -> class comparision is true

	Float comparision:
		NaN != NaN
		0.0 == -0.0
		NaN.equals(Nan) -> true
		0.0.equals(-0.0) -> false
		-0.0 < 0.0 < Infinity < NaN
		
	NaN is greater than everything

	Array comparision: 
		== -> referential 
	=> use contentEquals() or contentDeepEquals() for nested arrays

Koin vs Hilt:
	Hilt:
		Compile time: Dagger code generation
		Error detection at build time (missing bindings, scopes, ...)
		Runtim overhead: very low (generated code, fast lookup)
		App startup: faster and stable
		Build speed: slower
		Android integration, Multi-module large apps, testing
		KMP: limited
	Koin:
		Runtime: Kotlin DSL + light reflection
		Error detection: ar runtime (missing binding -> crash at start/use)
		Runtime overhead: higher (resolves graph at runtime)
		Build speed: faster		
		App startup: slower if graph is large
		Easier to learn
		More friendly to KMP
=> Hilt usecase: large apps, multiple modules, more performance, fail fast at compile time, deep android intergration
=> Koin usecase: small apps, quick setup, KMP, shorter build time

enum class vs seal class
	enum class:
		fixed set of constant values
		can add properties but all share same fields
	=> fixed set of constants
	seal class:
		restricted hierachu of types (subclass)
		each subclass can define its own properties and functions
	=> model a state machine or polymorphic hierachy

addAll vs plus vs += in List:
	addAll(collection): insert items into current list, change the original list, return boolean
	+= collection (Mutable): call allAll() -> insert items into current list
	+= collection (Immutable): creae a new list with new item
	plus (collection): create a new list with new items, return new list

find vs firstOrNull:
	find = firstOrNull
		find call firstOrNull
	find return null if not found

	find came first in early Kotlin
	firstOrNull was added later for API consistency: first, last, single, ...
	Today, find = firstOrNull

	single, singleOrNull {} -> expect exactly one element in the collection
	=> return the only element that matches the condition

Sealed class vs internal:
	sealed class is not internal by default -> public
	
	key distinction for a sealed class involves 2 rules"
		Subclass placement: The immediate subclasses must be defined in the same file or module as the sealed class itself.
		Constructor visibility: The constructor of a sealed class is protected by default, and can also be set to private. 
		It cannot be public. 
=>  you cannot extend a sealed class from a different module.
=> sealed only restricts where subclasses can be created (inside the same file), but doesn’t change the visibility.