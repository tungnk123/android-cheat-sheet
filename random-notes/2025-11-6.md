1. Two Loops Design

	- **Outer loop** (`restartTicker`) updates phase when reaching the next target (e.g., from Suhoor → Fasting).
	    
	- **Inner loop** (`tickUntil`) updates the countdown every second until the target time.
	    
	→ This cleanly separates slow-changing data (phase) from fast-changing data (countdown).

	**Optimization for XML UI**
	- Splitting state into two flows:
		- `PrayerPhaseUiState`: static info (title, labels, target)
		- `PrayerCountdownUiState`: dynamic countdown (hour/min/sec)
	→ Avoids rebinding entire UI every second in XML layouts.
	`Date()` gives current time; to get tomorrow → add one day using `LocalDate.plusDays(1)` or `Calendar.add()`.

2. `HijrahDate` = Islamic lunar calendar (used to display Hijri dates).

3. You can format the numbers to always show two digits using `String.format("%02d", value)`
4. Keep your current approach inline. Reserve string resources for static or translatable UI text, not dynamic numeric formatting that updates every second.
5. Check exist in Room
	1. The query

```
@Query("SELECT EXISTS(SELECT 1 FROM fasting_calendar WHERE epochDay = :epochDay AND fasted = 1)")
suspend fun isFasted(epochDay: Long): Boolean
```
	✅ **Purpose:** Quickly checks if a record exists for a given day that is marked as fasted.
	✅ **How it works:**
	- `EXISTS(...)` returns `1` if at least one matching row exists, else `0`.
	- Room converts that to `true` / `false`.
	    
	
	✅ **Result:** Efficient boolean check — no need to load entire rows, only confirms if that day was fasted.



6. **stateIn(..., started = SharingStarted.WhileSubscribed(...))**
	 Your upstream flow (e.g. Room Flow) only runs when it has at least one collector.
	 If nobody collects it → it stays idle → .value stays at initialValue (like emptyList()).
	StateFlow is hot — but It’s only kept hot after it starts.
	 WhileSubscribed delays starting until someone collects it.
	**Fix**
	If you just want .value to always update (no need to collect):
	stateIn(
	    scope = viewModelScope,
	    started = SharingStarted.Eagerly,
	    initialValue = emptyList()
	)
	→ Starts immediately, keeps emitting, .value works anytime.
	In short:
	 **WhileSubscribed** = runs only when collected.
	 **Eagerly** = always active.
	
	 Your initial `stateFlow.value` didn’t work because `SharingStarted.WhileSubscribed` only activates the upstream flow **when it’s being collected** — you never collected it, so it stayed at `initialValue` (`emptyList()`).

	`combine` works because it **collects** both flows continuously, which starts them and reacts to every update — keeping your UI data fresh.