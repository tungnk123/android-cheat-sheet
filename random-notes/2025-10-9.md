Broadcast Receiver context:
 	The context in a BroadcastReceiver only lives during onReceive() execution.
 
	After onReceive() returns, it can be garbage-collected — don’t keep or use it later.
 	For receivers declared in the manifest → the passed context is an Application Context.
 	For dynamically registered receivers → it’s the context of the registering component (Activity/Service).
 	If you need a context that safely outlives onReceive(), use:
	val appContext = context.applicationContext
 
	Never store the receiver’s context in a field or singleton (causes leaks).
 	Use it only for short tasks (start service, enqueue WorkManager, etc.).
=> In short: BroadcastReceiver context = short-lived; use context.applicationContext for anything persistent.

recyclerView.scrollToPosition() vs smoothScrollToPosition()

goAsync() is required when a BroadcastReceiver runs asynchronous work (e.g., coroutines, API calls, FusedLocationProviderClient).
Without it, Android may destroy the receiver as soon as onReceive() returns, canceling your async task or causing crashes.
✅ Use goAsync() → do async work → call finish() (or your helper finishPending()) when done.
 ❌ Skip it only if all work finishes synchronously inside onReceive().

@DrawableRes: -> add safety, tell AS the the value must be a <type> resource id
	-> static lint checking, warning, self-documenting, fewer runtime crashes, Prevent Resources.NotFoundException

	@DrawableRes, @StringRes, @ColorRes, @LayoutRes, @IdRes, @RawRes, @FontRes, @AnimatorRes, @AnimRes, @DimenRes

sealed class vs sealed interface:
	sealed class:
		can have state (properties, constructors)
		can inherit from another class
		can only be subclassed in the same file
		dont support multiple inheritance

	sealed interface:
		Cannot have state
		Can only inherit from only other interfaces
		Can be subclasses in other files in the same module
		multiple interfaces
=> sealed class: variants with data fields: Result, UiEvent, PlaybackState
=> sealed interface: types/behaviors possibly shared across files: Actionable, Loadable, Effect, ...

Scope function:
	with is not an extension function
	let -> Perform null checks in your code and later perform further actions with the returned object.
	apply -> Initialize objects at the time of creation.
	run -> Initialize objects at the time of creation AND compute a result.
	also -> Complete additional actions before returning the object.

Lambda expressions with receiver﻿: block: Canvas.() -> Unit
	Lambda expressions with receiver are also known as function literals with receiver.
	MutableList<Int>.() -> Unit

	MutableList<Int> as the receiver.
	No function parameters within the parentheses ().
	No return value: Unit.

	Since you have access to the receiver's member functions and properties without explicitly referencing the receiver, 
	your code becomes leaner. => Kotlin DSL