1. Kotlin Coroutines: 8 Patterns for Clean Async Code
	- ### Pattern 1: Repository Pattern with Coroutines
		- try { // Try cache first val cachedUser = database.getUserById(userId) 
		- if (cachedUser != null) return@withContext Result.success(cachedUser) 
		- // Fetch from network val networkUser = api.getUser(userId) 
		- // Save to cache database.insertUser(networkUser) Result.success(networkUser) } catch (e: IOException) {
		- // Network error - return cached if available database.getUserById(userId)?.let { Result.success(it) } ?: Result.failure(e) }
	- ### Pattern 2: Use Case Pattern with Result Types
		- Without use cases, business logic scatters across ViewModels, making code hard to test and maintain. ViewModels become bloated with business rules that should be separated.
		- Mixing business logic with UI logic creates several issues:
			- **Hard to Test**: Business logic tied to ViewModel lifecycle is difficult to unit test
			- **Code Duplication**: Same logic repeated across multiple ViewModels
			- **Tight Coupling**: ViewModels depend directly on repositories, making changes risky
			- **No Reusability**: Business logic can't be reused in different contexts
			- **Poor Separation**: Violates single responsibility principle
		=> Extract business logic into use cases with Result types
	- ### Pattern 3: Sealed Result Types for Error Handling
		- sealed class DataError : Exception() { object NetworkError : DataError() object NotFound : DataError() data class ServerError(val code: Int, val message: String) : DataError() data class UnknownError(val throwable: Throwable) : DataError() }
		- sealed class Result<out T, out E : Throwable>
	- ### Pattern 4: Parallel Execution with coroutineScope
		- Use `coroutineScope` for parallel execution
		- async + await
	- ### Pattern 5: Retry Logic with Exponential Backoff
		- Simple retries create several problems:
			- **Server Overload**: Rapid retries can overwhelm servers
			- **Wasted Resources**: Retrying immediately often fails again
			- **Battery Drain**: Constant network requests drain battery
			- **No Backoff**: Doesn't give network time to recover
			- **Poor Reliability**: Doesn't handle transient network issues
	- ### Pattern 6: Flow-Based Data Streams
		- Manual polling creates inefficient code that wastes resources and doesn't react to data changes automatically.
		- Manual polling creates several issues:
			- **Inefficient**: Fetches data even when nothing changed
			- **Battery Drain**: Constant polling drains battery
			- **No Reactivity**: Doesn't automatically update when data changes
			- **Complex Lifecycle**: Manual management of polling lifecycle
			- **Race Conditions**: Multiple polls can cause race conditions
	- ### Pattern 7: SupervisorJob for Independent Operations
		- With regular `coroutineScope`, one failure cancels all operations, even when they're independent and should continue.
		- => supervisorScope
	- ### Pattern 8: Dispatcher Management and Context Switching
		- Use proper dispatcher
		- withContext
2. Scope in Singleton with applicationContext
	- @ApplicationScope for scope
	- scope = CoroutineScope(Main.immediate)
3. **Concise Summary – Best Practices Learned**
	- **Do NOT use** `**Resource**` **with Flow** in large apps
	→ It mixes state & event, causes replay bugs, hard to scale.
	- **Separate responsibilities**
		- **Data** → `StateFlow<T>`
		- **Loading** → `StateFlow<Boolean>`
		- **Error / Toast / Nav** → `SharedFlow<Event>`
	- **State vs Event**
		- State = persistent (list, loading)
		- Event = one-shot (error, toast)
	    

	- **Query handling**
	- Each tab/feature has **its own query**
	- **All tab** → API search + loading
	- **Favorite tab** → local DB filter, no loading
	- **Flow operators**
		- Side-effects → `onEach`
		- Transform data → `map`, `combine`
		- Avoid `flatMapLatest` unless returning a real Flow
    
	- **UI models**
		- Entity ≠ UI model
		- Derive UI state with `combine()`
		- Favorite = existence in DB, not a flag
	- **RecyclerView**
		- Single source of truth
		- No manual `notifyItemChanged`
		- Selection by stable ID (e.g. `url`)
	- **Architecture used by senior devs / large GitHub apps**
		- StateFlow + SharedFlow
		- UiState + UiEvent pattern
		- No `Resource` wrapper
		- Clear, scalable, testable
    

**Bottom line:**

> _Flow-based apps scale best when state is explicit, events are one-shot, and each feature owns its own logic._


4. 