- Bug submodule:
	- cd android-core
	- git checkout develop
	- Why: in empty branch
- Google map api key: fake vpn billing to singapore
---

1. **BroadcastReceiver Registration Crash**
	- **Root cause:** Attempting to unregister a receiver that wasn't registered or was already unregistered
	- **Solution:** For sticky broadcasts like `ACTION_BATTERY_CHANGED`, don't register receivers at all - just query the sticky broadcast on-demand and poll periodically
	- **Why:** Sticky broadcasts maintain their last value, so you can read them anytime without registering a listener
2. **Missing Layout Resource Crash**
	- **Root cause:** `resources.getLayout()` doesn't validate resource existence - crash happens during inflation
	- **Solution:** Use `resources.getResourceName()` to validate resources exist before using them, with fallback to default layout
	- **Why:** Some layouts may not exist in all build variants/flavors
3. **Fragment Not Attached Crash**
	- **Root cause:** Coroutines/callbacks accessing `requireActivity()` or activity-scoped ViewModels after Fragment is detached
	- **Solution:**
		- Use `viewLifecycleOwner.lifecycleScope` instead of `lifecycleScope`
		- Check `isAdded` before accessing Activity/ViewModels in async code
		- Check `isInitialized` for lateinit properties
		- Use safe casts (`as?`) when getting Activity reference
		- **Why:** Fragment lifecycle is complex - view lifecycle and fragment lifecycle are separate; async operations can outlive the attachment to Activity
4. **Core Principles**
	- Leverage Android's built-in mechanisms (sticky broadcasts) instead of manual lifecycle management
	- Always validate resources before use in multi-variant apps
	- Respect lifecycle boundaries in async operations - use appropriate lifecycle scope and add existence checks
5. **OpenGL 3.0** is a graphics API for rendering 2D/3D content using the GPU. 
	- **Mapbox use:** Mapbox **does not directly use OpenGL 3.0**.
	- It uses **OpenGL ES (mainly ES 2.0 / ES 3.x)** on mobile and **Metal (iOS) / Vulkan or OpenGL ES (Android)** under the hood for map rendering.
6. StickyBroadcast:
	- `ACTION_BATTERY_CHANGED` is a **sticky broadcast**
	- Sticky broadcasts do NOT require registering receivers
	- `unregisterReceiver()` crashes if receiver not registered
	- Singleton + Activity lifecycle = dangerous
	- Prefer **polling + StateFlow** for system state
	- `stateIn + SupervisorJob` = safe shared state
	- Activities should **never control singleton lifecycles**
	- A **sticky broadcast** is a special Android system broadcast where the **last sent Intent is kept by the system** and can be retrieved **any time later**, even if you did **not register a receiver when it was sent**.
	- Normal broadcast → **fire & forget**
	- Sticky broadcast → **fire, keep, and reuse**
	- Can be retrieved anytime via `registerReceiver(null, filter)`
	- No receiver lifecycle needed
	- Only system can send sticky broadcasts
	- Perfect for battery, storage, power state
	- Avoids `unregisterReceiver()` crashes
	- ACTION_BATTERY_CHANGED
	- ACTION_DOCK_EVENT
	- ACTION_DEVICE_STORAGE_LOW
	- ACTION_DEVICE_STORAGE_OK

	- **Why:**
		- Sticky broadcasts are **system-managed**
		- You can **query them directly** without registering a receiver
    
	- **Example (battery):**

		`val intent = context.registerReceiver(null, IntentFilter(Intent.ACTION_BATTERY_CHANGED))`

	- **When a** `**BroadcastReceiver**` _**is**_ **needed**
		- You want **continuous updates over time**
		- You need to react to **future changes**, not just current state