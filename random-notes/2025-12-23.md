1. android:clickable="true" android:focusable="true" android:focusableInTouchMode="true" => below view cannot click or focus
2. 400: Bad Request 401: Unauthorized 403: Forbidden 429: Rate Limited 500: Server Error
3. Below is the **complete, senior-level explanation** of **why** `**Resource**` **should NOT be used with** `**StateFlow**`, with **real bugs, concrete examples, correct use cases, and when it** _**is**_ **acceptable**.

	- **1. What** `**Resource**` **was originally for**
	- `Resource<T>` was created for **LiveData-era MVVM**.

	- Typical use:

```
LiveData<Resource<List<User>>>
```

	- Why it made sense **back then**:
		- LiveData has **no concept of event**
		- No `SharedFlow`
		- No easy `combine`
		- UI was mostly **imperative**
So `Resource` bundled
- data
- loading
- error
into **one observable**
➡️ This was a **workaround**, not an ideal model.
	**2. Why** `**Resource**` **breaks with** `**StateFlow**`
	**Core problem**
	`StateFlow` **replays the latest value to every new collector**.
	But `Resource` mixes:
	- **State** (data, loading)
	- **Event** (error)
	That causes **real bugs**.

**3. Real bug #1 – Error replay (very common)**

- **Code**

```
val usersFlow = MutableStateFlow<Resource<List<User>>>(Resource.Loading)
```

UI:

```
collect {
    when (it) {
        is Resource.Failure -> showToast(it.message)
    }
}
```

**What happens**
1. API fails → `Resource.Failure("Network error")`
2. User rotates screen
3. New collector subscribes
4. **Failure is replayed**
5. ❌ Toast shows again
**Why this is wrong**
- Error is an **event**
- StateFlow **must not replay events**
- User didn’t trigger anything
➡️ This is a **design bug**, not misuse.
**4. Real bug #2 – Loading flicker**
**Sequence**
```
Loading → Success → Loading → Success
```
Why?
- Any refresh or retry emits `Loading`
- UI hides list, shows spinner again
- List flickers even if cached data exists
**With StateFlow**
StateFlow **remembers** `Loading`
So:
- navigate back → loading flashes again
➡️ Senior devs hate this UX.
**5. Real bug #3 – Impossible** `**combine()**`
**Example**
You want:
- song list
- favorites
- search query

With Resource:

```
combine(
  songsResourceFlow,
  favoriteFlow,
  queryFlow
)
```

Now you must handle:
- `Loading + Success`
- `Failure + Success`
- `Loading + Failure
This explodes combinatorially.
➡️ `Resource` **does not compose**.

**6. Conceptual mismatch (the real reason)**

**Flow philosophy**

> **One Flow = One Responsibility**

But `Resource` does:
- data
- loading
- error
➡️ Violates Flow design principles.
**7. Correct mental model (used by senior devs)**
**Split responsibilities**
Concern
Correct tool
UI data
`StateFlow<T>`
Loading
`StateFlow<Boolean>`
Error / Toast
`SharedFlow<Event>`
Navigation
`SharedFlow<Event>`
Why?
- State survives rotation
- Event does NOT replay
- Easy to test
- Easy to combine

**8. Correct replacement pattern (example)**

**ViewModel**

```
val songs = MutableStateFlow<List<Song>>(emptyList())
val isLoading = MutableStateFlow(false)
val errorEvent = MutableSharedFlow<String>()
```

**Load logic**

```
isLoading.value = true
try {
    songs.value = repo.loadSongs()
} catch (e: Exception) {
    errorEvent.emit("Network error")
} finally {
    isLoading.value = false
}
```

**UI**

```
collect(songs)
collect(isLoading)
collect(errorEvent) { showToast(it) }
```

No replay bug. No flicker. No confusion.

**9. When** `**Resource**` **is STILL acceptable**

**✅ Acceptable cases**

- LiveData (not Flow)
- Very small demo apps
- One-shot screens
- Learning projects
- No events (toast, nav)
Example:

```
LiveData<Resource<User>>
```

**10. When** `**Resource**` **should be avoided (your case)**

- Using `StateFlow`
- App has multiple screens
- Has search / filter / paging
- Uses `combine`
- Has toast, snackbar, navigation
- Needs scalability
    

➡️ **All modern production apps**

**11. What large GitHub projects & senior devs use**

- **Google NowInAndroid**

- `UiState` (StateFlow)
- `UiEvent` (SharedFlow)
- ❌ No Resource

- **Airbnb Mavericks**

- Immutable state
- Events separated
- ❌ No Resource
    

- **Square / Cash App**
- StateFlow + EventFlow
- ❌ No Resource
- **Jetpack Paging**
- `PagingData` + `LoadState`
- ❌ No Resource
    

**12. Final rule of thumb (memorize this)**

> **If you use StateFlow, you should not use Resource**

Because:

- StateFlow already solves state
- SharedFlow already solves events
- Resource becomes redundant and harmful

**Ultra-short knowledge summary (notes)**
- `Resource` = legacy LiveData pattern
- StateFlow replays → breaks error handling
- Loading ≠ Error ≠ Data
- Events must NOT be replayed
- `StateFlow` = state
- `SharedFlow` = event
- `combine()` + Resource = nightmare
- Senior devs avoid Resource with Flow
- Modern apps split state explicitly

**Bottom line:**
`Resource` is not wrong — it’s **outdated** for Flow.


3. Kotlin 2.2 Just Changed How You Refactor, Generate and Automate Android Apps
	- The Jetpack Compose compiler was integrated with Kotlin 2.2. Recomposition is smarter. Savings on state — from 20–30% less management overhead Your UI will now be re-rendered without a reason.
	- 40% Faster Build Times
	- K2 delivered a 25–30% reduction in build times and a 15% reduction in APK sizes without requiring any source code changes for large projects (500+ files).
	-  Amper is our experimental Kotlin-first build tool, and it now ships with Android Studio. Do it in Kotlin, not in XML, not in Groovy — define all of your build pipeline in Kotlin.