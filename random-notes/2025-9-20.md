Pipes
	General Java feature, not Android-specific.
	Provides a one-way channel between two threads in the same process.
	Producer writes → consumer reads.
	Internally a circular buffer, accessible only to the two connected threads (thread-safe).
	Good for long-running tasks where one continuously offloads data to another.
	Can carry binary or character data.
	Lifetime: from connection (writer or reader) until closed.

Shared Memory
	Uses heap memory for inter-thread communication.
	Local variables are private to a thread; shared data must be stored in instance or class fields.
	References live on each thread’s stack, but objects live in the shared heap.
	Threads communicate by accessing these shared objects/fields.

⚡ Key difference:
	Pipes → structured, one-way, continuous data transfer.
	Shared memory → general object sharing in heap; flexible but requires careful synchronization.

Process vs Thread vs Coroutine:
	A program = an executable file containing a set of instructions and passively store on disk
	One program can have multiple processes. Exp: Chrome create a different process for every single tab

	A process = a programe in execution (loaded into the memory and becomes active)
	Process requires some essential resources such as registers, program counter, and stack

	1. The program contains a set of instructions. 
	2. The program is loaded into memory. It becomes one or more running processes. 
	3. When a process starts, it is assigned memory and resources. A process can have one or more threads.

	Process = indepdendent program (a running app) in execution with its own memory space and system resources (CPU, memory)
	Process dont share memory by default and need special mechanism for communication (IPC like pipes or sockets)
	Switching between processes is slower due to the overhead of saving/restoring states an memory mapping
	
	Thread = the smallest unit of execution within a process
	Thread share the memory of the process they belong to -> fast and efficient communication
	Thread switching is faster since threads within the same process use the same resources

	Coroutine = A lightweight concurrency unit (task) managed at the language/runtime level, not the OS.
		Runs inside a thread; thousands of coroutines can share one thread.
		Uses suspension and resumption instead of blocking → no dedicated stack.
		Extremely cheap to create/switch (no kernel context switch).
		Best for tasks like network requests, async I/O, structured concurrency.
		Summary: Cooperative, super-light tasks within threads, great for high concurrency.

	=> Process (hard): heavy, independent, multi-process parallesism, commucation via IPC, managed by OS Scheduler
	=> Thread (medium): medium unit of execution, multi-threading, communication via shared memory, pipes, synchronization
	=> coroutine (flow): lightweight task in a thread, share memory, cheap, concurrency (suspends, resume cooperatively)
		communication via Channels, Flows, SharedFlow, Mutex
		managed by CoroutineDispatcher + structured concurrency
		uses cooperative suspension instead of OS scheduling, best for high concurrency

	Process components: ProcessID, ParentProcessID, Code (Program instructions to execute), Registers, Address Space 
		Heap (shared memory)
		Stack
	Thread components: 
		ThreadId, ProcessID, Program Counter (points to the current instruction)
		registers: private, each thread has its own register set
		Stack: own stack (for method calls, local variables)
		Shared Resources: share the process's code, heap ...
	=> thread keep its own stack and registers


Kotlin Source Code (.kt)
      ↓ kotlinc → JVM Bytecode (.class)
      ↓ D8/R8 → Dalvik Executable (.dex)
      ↓ Packaged into APK / AAB (contains .dex + resources)
      ↓ Upload to Google Play
      ↓ Downloaded & installed on device
      ↓ ART (Android Runtime) loads .dex into memory
      ↓ JIT (Just-In-Time) / AOT (Ahead-Of-Time) compile to native ARM/ARM64
      ↓ CPU executes machine instructions