block: NotificationBuilder.() -> Unit
=> function type with Receiver in Kotlin

fragment in a fragment -> use childFragmentManager

How to import multiple R into a class
	-> Use type alias (as)
	example: import <>.R as CoreR
		import <>.R 

How to inject a Map using Hilt
	@IntoMap
	@StringKey("madani")

SQLDelight code-first vs Room annotation-first

items vs itemList:
	items:
		talk about the collection/flow of data (plural, the set of things)
	itemList:
		you want to be explicit that this is a List<T> implementation 
	=> items = a general collection (could be Flow, LiveData or array)
	=> itemList = emphasizes that the type is specifically a List

	Usecase:
		Exposing via FLow/LiveData -> items (abstract, UI dont care about type)
		Backing store in adapter/viewmodel -> itemList
		Function parameter -> items -> generic
		Multiple collections in same class -> items
		Iterating inside UI (Compose/Swift UI) -> items

Builder pattern
	"telescoping constructor" problem

	we'll leverage the power of Kotlin's Type-Safe DSLs to create a truly beautiful and fluent object-building experience

	The Naive Approach: Telescoping Constructors or apply

	The Solution: The Builder Pattern with a Kotlin DSL

	Step 1: The (Immutable) Target Class
		-> making its constructor internal
	Step 2: Create the Builder Class
		@DslMarker
		annotation class NotificationDsl
		=> prevents nesting builders incorrectly (e.g., putting a notification block inside another notification block)
		
		@NotificationDsl
		class NotificationBuilder { title, message, icon, action, build() }

		@NotificationDsl
		class ActionBuilder { }

	Step 3: Create the Top-Level Builder Function (The DSL Entry Point)
		fun notification(block: NotificationBuilder.() -> Unit): Notification {
    			val builder = NotificationBuilder()
    			builder.apply(block)
    			return builder.build()
		}

	Benefits:
		Separation of Concerns: The NotificationBuilder handles the complex construction logic, while the Notification 
		class is just a simple, immutable data holder.
		Readability and Fluency: The DSL makes the creation process extremely clear and easy to understand.
		Immutability: It allows us to create fully immutable Notification objects, which is much safer in multi-threaded 
			environments and reduces bugs.
		Flexibility: It's easy to add new optional parameters to the Notification without breaking any existing client code. You just add a new property to the builder.

