Object in Koltin
-> singleton + lazy + thead-safe manner


Jetpack Compose triggers recomposition when it detects changes in observable state — such as mutableStateOf, StateFlow, or values 
	tracked via remember.

What can happen if you don’t provide stable keys in a LazyColumn?
-> Scroll position and item state may behave incorrectly
	If you don’t provide a stable and unique key in a LazyColumn, Compose uses the item’s position as the key.
	This can cause issues when the list updates — items may appear to jump, scroll position can reset, or the wrong state 
		(like checkbox status or focus) may be reused.
	Providing a stable key (like item.id) helps Compose efficiently track item identity across recompositions.


Job.cancel() vs scope.cancel():
	Want to cancel a single coroutine? → Use job.cancel()
	Want to cancel all coroutines and deactivate the scope?
		→ Cancel the Job that backs the scope — either directly via job.cancel(), or (in scopes like MainScope) via scope.cancel()
	Need cleanup at the end of a lifecycle (e.g., Activity, ViewModel)?
→ Use lifecycle-aware scopes provided by Android, or cancel the backing Job manually if you're using a custom scope

	Need to cancel all children coroutines within a scope BUT keep a scope as active and alive
	-> scope.coroutineContext.cancelChildren()