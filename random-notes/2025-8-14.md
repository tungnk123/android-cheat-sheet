Blob = Binary Large Object -> store large amount of unstructed data

DNS in android app -> DNSModule with Hilt
	OkHttp use default DNS from system ISP (InetAddress.getAllByName(hostname))

	DNS over HTTPs (DoH) = sends DNS lookup through HTTPs instead of plain text -> no one can intercept or tamper with them easily
		Add dependency in OkHttp	
		val cloudfareDns = DnsOverHttps.Builder()
			.client(boostrapClient)
			.url("https://1.1.1.1/dns-query".toHttpUrl())
			.build()

	A resolver is like the “DNS agent” that knows where to ask for an IP address.
 		Here you’re telling your fallback agent:
 		“Ask Google first. If Google can’t help, ask Cloudflare.”	

	Inscreased security: 
		DNS over HTTPs (DoH) like cloudfare DNS, DNS queried
		ISPs and thirds parties can't easily block and monitor the domains you access
		Reduced DNS spoofing risk
	More control & customization: 
		choose faster DNS providers (Cloudfare, GoodleDNS) to improve speed
		use fallback strategies (MultiDNS) if the main DNS fails
	Better user experience: reduced downtime, lower latency
	DNS cache: save DNS lookup into cache file -> increase network speed, reduce DNS request, stable network
	DoH can  bypass ISP DNS blocking

System Design for Spofity
	Mobile app -> LoadBalancer -> WebServer -> Blob storage (songs) + SQL (metadata, users)

	Scaled solution:
		Caching: LRU (Least Recently Used) eviction policy
		CDN
		Leader-Follower Database

The Hidden Cost of Kotlin’s lazy Delegate in Android
	property’s value is not computed until the first time it’s accessed.
	-> deferring the loading of large resources, avoiding unnecessary work during app startup, or creating objects only if 
		they’re actually needed.

	Kotlin’s lazy delegate isn’t free
	it generates extra bytecode, allocates additional objects, and adds a method‑call layer compared to a plain property.

	Lazy Initalization
		Defers computation until the first time it’s accessed.
		Backed by Kotlin’s Lazy interface.
		Uses a lambda for the initialization logic.
		Optionally supports thread‑safety modes (SYNCHRONIZED, PUBLICATION, NONE).

	=> Extra bytecode size (delegate field, lambda class)
	Slight runtime overhead on each access
	Can be overkill for trivial or always-used values

	Use lazy when:
		lazy shine when Initialization is expensive (parsing JSON, loading large resources).
		You might not need the object at all in some runs.
		When first-access deferral yields better startup performance

SqlDelight = a library by Square that lets you write SQL in a .sq file and automatically generates type-safe Kotlin code for your
	codebase schema and queries
	
	Key points:
		type safe
		compile time verification
		low boiterplate code
		migration support
		multiplatform: on Android, iOS, JVM, JS
		flexibility
=> Room = easiet for Android apps with Jetpack
=> SqlDelight = type-safety, multiplatform, direct SQL
=> Realm = no SQL, object database, multiplatform

Room vs Realm vs Exposed vs SQLDelight
	Room:
		ORM over SQLite
		For Android
	Realm:
		Object DB
		KMP
	Exposed:s
		SQL DSL
		Server, Android/JVM
	SqlDelight:
		SQL generator over SQLite
		KMP
=> Android-only + Jetpack intergration -> Room
=> KMP + no SQL + live objects -> Realm Kotlin
=> Server-side on Android JVM project, want SQL DSL -> Exposed
=> KMP + full SQL control + type safety -> SQLDelight