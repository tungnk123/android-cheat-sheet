Refactoring a ViewModel: From Reactive Workarounds to Constructor Injection
	Issue:
		It didn't receive its required data (itemId) at construction time. Instead, the value was passed in later using a 
		LaunchedEffect. Internally, the ViewModel used a StateFlow initialized with null, combined with stateIn, and tied to 
		reactive streams that depended on UI timing.
	=> Delayed initialization The itemId was not passed during ViewModel construction. Logic depending on it was delayed, making the 
	setup sensitive to timing.
	=> Using MutableStateFlow<String?> with null as the initial value added noise and forced null checks throughout the code.
	=> The LaunchedEffect looked harmless, but it was essential to trigger the ViewModel logic. That dependency wasn't obvious and 
		could easily be overlooked.
	=> Limited testability The ViewModel couldn't be constructed with complete state. Tests had to simulate post-construction setup, 		
		adding complexity and brittleness.

	Solution: @AssistedInject
	-> combining injected dependencies with parameters that must be provided at runtime

	By marking itemId as @Assisted, we were able to supply it during ViewModel creation — avoiding late binding, nulls, and reactive 
	workarounds.

	Why This Is Better
		Direct parameter injection itemId is passed at construction time. No need for flows or null placeholders.
		Simplified state management No StateFlow, no stateIn, and no manual filtering.
		Improved lifecycle clarity Initialization logic is self-contained in the ViewModel. No dependency on external LaunchedEffect.
		Better testability Tests can now create the ViewModel with a valid ID — no additional setup required.


	The change to constructor injection with @AssistedInject helped us:
		Make the ViewModel self-contained: No external side effects were required to start its logic.
		Improve testability: Tests could now provide the required argument directly.
		Simplify recomposition and screen restore: There were no hidden reactive dependencies or timing assumptions.
		Improve code readability: The required parameters were explicit and enforced by the type system.

SavedStateHandle with Hilt + Navigation compose
	hiltViewModel() -> Injects ViewModel + auto-binds SavedStateHandle
	Navigation Compose + Hilt -> provide SavedStateHandle


Hilt Assisted Injection
	When to use? -> where a ViewModel needs both:
		1. dependencies that Hilt can provide automatically, and
		2️. a parameter (itemId) that only exists at runtime (from navigation).

	@AssistedInject constructor(...) -> This tells Hilt (or Dagger):
	“This class should be created using assisted injection — some of its parameters are provided by Hilt, and some are provided 		
		manually when creating the instance.”

	@Assisted private val itemId: String 
	-> “This parameter must be passed manually when constructing the object through an @AssistedFactory.”

	@AssistedFactory -> Factory interface to build instances with assisted params

	Common usecase:
		Detail or profile screen -> Need itemId, userId, or postId passed from navigation
		Dialog ViewModel -> Need runtime config like DialogConfig or MessageId

ArrayMap vs HashMap vs SparseIntArray:
	HashMap:
		HashMap scales much better for large, random-access, and frequently-mutated data sets.
		It has O(1) amortized lookup, insert, and remove operations.
		Internal structure (buckets + hash table) avoids costly array shifts.
	=> Large or highly dynamic maps

	ArrayMap:
		Memory efficiency: ArrayMap often uses less memory than HashMap, especially for smaller datasets.
		Performance: ArrayMap can be faster than HashMap for certain operations, particularly when the number of elements is small.
		Order preservation: Unlike HashMap, ArrayMap maintains insertion order.
		Key type: Any
		Same interface as HashMap, but stores entries in compact arrays (no nodes).
		Uses hashing but avoids Entry objects → ~2× smaller memory than HashMap.
		Slightly slower for large maps because resizing and searching arrays are costlier.
	=> Small general-purpose key-value pairs (String, Object, etc.)	
	
	Sparse types (SparseArray, SparseIntArray, etc.) become slower when:
		You have tens or hundreds of thousands of entries.
		Keys are randomly distributed (not increasing).
		You frequently insert/delete in the middle → requires shifting elements (O(N)).

		For small N (typically < 1,000–2,000 items), the GC and boxing cost of HashMap dominates.
		Sparse collections store primitive arrays (no Integer boxing, no Node objects).	
		Better cache locality, fewer allocations, less GC, especially critical for UI performance.	
		
		Great for UI-level state, RecyclerView positions, adapters, etc.
		Dies off when N grows large → binary search + array shifts = slow.
	=> int → object/primitive mappings (UI state, small caches)

=> Use Sparse for small, primitive, performance-critical data.
=> Use HashMap for big, complex, or frequently changing data.
=> Use ArrayMap for small general-purpose maps.


Interface:
	Their functions and properties are implicitly inheritable by default. In Kotlin, we say that they are "open."

Delegation:
	Interfaces are useful, but if your interface contains many functions, its child classes can end up with a lot of boilerplate code. 
	If you only want to override a small part of a class's behavior, you need to repeat yourself a lot.

	Boilerplate code is a chunk of code that is reused with little or no alteration in multiple parts of a software project.

	you can delegate the interface implementation to a class instance using the by keyword

Objects in Kotlin are lazy, meaning they are created only when accessed. 
Kotlin also ensures that all objects are created in a thread-safe manner so that you don't have to check this manually.

data objects automatically come with additional member functions: toString() and equals().
Unlike data classes, data objects do not come automatically with the copy() member function because they only have a single instance that 
	can't be copied.