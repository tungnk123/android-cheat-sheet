Stop Rewriting Boilerplate. Start Using Kotlin Delegation!
	Every developer knows the pain: repeatedly writing the same methods that just forward calls to another object. 
	It clutters your classes, makes them harder to read, and opens the door for bugs.
	This pattern, often called the Decorator or Proxy pattern, is essential but tedious.

	Class Delegation is a language feature that allows a class (the delegatee) to handle a subset of the methods of an interface for
	 the class that implements it (the delegator).
	=> “Hey, I’m implementing this interface, but I want this other object to handle all its methods for me."

	class DelegatedTimestampedLogger(
    		private val logger: LogWriter
	) : LogWriter by logger {
		override fun logMessage(level: String, message: String)
	}

	The boilerplate code that is reduced is the trivial forwarding code for the methods you intend to pass through unchanged

	Kotlin supports delegating multiple interfaces. You just use the by keyword for each one. 
		class MyMultiTasker : InterfaceA by aInstance, InterfaceB by bInstance { ... }

	Class Delegation (class MyClass : Interface by delegate): Deals with interface implementation and method forwarding.
	Property Delegation (val x by lazy { ... }): Deals with property getter/setter implementation and custom logic when a property 
		is accessed or modified.

Reduce App Size:
	The Play Store’s data showed that for every 6 MB increase in APK size, we lost 1% of installs.
	
	1. Identify app size detail with APK Analyzer
	
	Strategy 1: Image Optimization (Saved 38 MB)
		Step 1: Convert PNG to WebP
		Step 2: Remove Unnecessary Densities
			Solution: Ship only xxhdpi, xhdpi and let Android scale down
		Step 3: Use Vector Drawables
			Icons and simple graphics were perfect candidates for VectorDrawables.
		Step 4: Implement On-Demand Image Downloads
			=> Download on-demand with caching (Coil or Glide)
	Strategy 2: Native Library Optimization (Saved 22 MB)
		Step 1: ABI Splitting
			We shipped separate APKs for different architectures using App Bundles.	
			abi {
            			enableSplit = true
        		}
			density {
            			enableSplit = true
        		}

		Step 2: Remove Unused Native Libraries
			We were bundling all ExoPlayer extensions, including unused ones.
	Strategy 3: Asset Optimization (Saved 18 MB)
		Step 1: Move Tutorial Videos to CDN
		Step 2: Optimize Font Files
		Step 3: Compress JSON Configuration Files
			GZIPInputStream 

	Strategy 4: Code Optimization (Saved 4 MB)
		Step 1: Enable R8 Full Mode, code shrinker and obfuscator
		Step 2: Remove Unused Dependencies
		Step 3: Use Android App Bundle Features
			App Bundles allow on-demand feature delivery.

	Strategy 5: Resource Optimization (Saved 5 MB)
		Step 1: Remove Unused Resources
			shrinkResources true
            		minifyEnabled true
		Step 2: Localization Optimization
			Solution: Ship only top languages, download others on-demand

=> Use CI/CD to monitor app size

Prefer using an expression body for functions with the body consisting of a single expression.

Coding convention for libraries:
	always explicitly specify member visibility (avoid public in API)
	always explicitly specify function return types and property types
	provide KDoc document for all public members