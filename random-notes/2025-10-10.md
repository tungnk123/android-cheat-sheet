Broadcast Receiver context:
 	The context in a BroadcastReceiver only lives during onReceive() execution.
 	After onReceive() returns, it can be garbage-collected — don’t keep or use it later.
 	For receivers declared in the manifest → the passed context is an Application Context.
 	For dynamically registered receivers → it’s the context of the registering component (Activity/Service).
 	If you need a context that safely outlives onReceive(), use:

	val appContext = context.applicationContext
 	Never store the receiver’s context in a field or singleton (causes leaks).
 	Use it only for short tasks (start service, enqueue WorkManager, etc.).
=> In short: BroadcastReceiver context = short-lived; use context.applicationContext for anything persistent.

goAsync() is required when a BroadcastReceiver runs asynchronous work (e.g., coroutines, API calls, FusedLocationProviderClient).
Without it, Android may destroy the receiver as soon as onReceive() returns, canceling your async task or causing crashes.
✅ Use goAsync() → do async work → call finish() (or your helper finishPending()) when done.
 ❌ Skip it only if all work finishes synchronously inside onReceive().

Cause: Your saveResultsToDatabase() runs in viewModelScope. When the Activity stops/VM clears, the scope is canceled mid-flush—hence 
	logs stop at [2/5].

=> Fix options (pick one):
 	Application-wide scope: Inject an app CoroutineScope(SupervisorJob + Dispatchers.Default) and launch the flush there (won’t cancel with VM).
 	NonCancellable: Wrap flush in withContext(NonCancellable) inside viewModelScope (safer, but still depends on launch timing).
 	WorkManager: Enqueue a background job—most robust and survives app kills.
=> Extras:
 	Batch DB writes (e.g., toggleBookmarks(list)) in one transaction.
 	Don’t clear() pending until after a successful flush (or keep a copy for retry).
 	Trigger flush earlier (e.g., on back press or debounced), not just onStop().
 	Add start/end/cancel logs to confirm execution.

properties = fields + getter/setter

abstract class in interface:
	abstract class: -> is a 
		share behavior, state and logic between subclasses
		single inheritance
		can have field (instance variables, constructor)
		Can have methods with implementation: both normal and abstract methods
		can have a properties, state (store a value)
	
		default methods: can store, modify and rely on the internal state

	interface: -> can do
		define a contract (behaviors)
		multiple inheritance
		CANNOT have field (instance variables, constructor), only constant allow
		Can only have default methods
		can have static implementation -> methods or constants belong to the type itself, not instance
		can only use logic, not own or manage state
=> abstract class: share state and logic (method)
=> interface: share capability, behavior

Sealed class vs sealed interface:
	sealed class:
		A sealed class itself is always an abstract class
		it may contain or inherit constructors
		Constructors of sealed classes can have one of two visibilities: protected (by default) or private

		enum classes can't extend a sealed class, or any other class. However, they can implement sealed interfaces

		There is one more inheritance restriction in multiplatform projects: direct subclasses of sealed classes must reside 
		in the same source set


	=> subclasses must be in the same package (java) or same file (Kotlin
	sealed interface:
		cannot hold state or implementation (only default, static methods)
		abstract properties only or constants
	
=> sealed class: shared logic of fields, variant hierarchy
=> sealed interface: conceptual grouping (marker or union type), multiple inheritance