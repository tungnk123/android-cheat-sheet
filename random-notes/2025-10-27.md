lifecycleScope and viewModelScope use Dispatcher.Main.immediate as default

GlobalScope.launch { ... } without specifying a dispatcher, it uses the default dispatcher

About Dispatchers.Default
	It uses a shared background thread pool optimized for CPU-intensive work.
	The number of threads is typically equal to the number of CPU cores.
	It’s not confined to the main thread, so you can’t update UI directly from this coroutine.


lifecycleScope.launch {
        println("a")
    }
    
    GlobalScope.launch {
        println("b")
    }

    println("c")
=> print A, C, B

Use suspend for operation in Retrofit

Request runtime permissions
 (ACCESS_FINE_LOCATION, ACCESS_COARSE_LOCATION)
 → ensures your app can access location.

 Check and enable Location Services
 using SettingsClient.checkLocationSettings(...) with a LocationRequest
 → ensures GPS / network location is turned on.

 Only then request actual location updates
 via FusedLocationProviderClient.
=> Always request permission first, then use LocationRequest + SettingsClient to ensure GPS is enabled.


If you use primitives in an object-type array, this has a performance impact because your primitives are boxed into objects. To avoid boxing overhead, use primitive-type arrays instead.
	IntArray, LongArray, ShortArray, FloatArray, DoubleArray, BooleanArray

An array holds a fixed number of values of the same type (or subtype).
Use arrays when you need fixed-size, low-level collections; for general use, prefer Kotlin collections.
Arrays are mutable and invariant in Kotlin (you cannot assign Array<String> to Array<Any>)
Use the spread operator (*) with vararg when passing array elements as separate arguments.Use .contentEquals() or .contentDeepEquals() to compare array contents; == checks reference equality.
 Use functions like .sum(), .shuffle(), conversions .toList(), .toSet(), .toMap(). 

For better performance (avoiding boxing), use IntArray, BooleanArray, CharArray, etc instead of Array<Int> etc. 
 Primitive arrays are separate classes (not subclass of Array<T>) but provide similar functionality.
 Conversion: .toTypedArray() from primitive to object-type, and .toIntArray() etc for reverse.

=> Because arrays are fixed size and less flexible (no easy add/remove, equality behavior differs), for most cases Kotlin collections (List, MutableList, etc) are preferred.


