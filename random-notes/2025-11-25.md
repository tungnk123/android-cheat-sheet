
---
1. The Real Difference Between `withContext(Dispatchers.IO)` and `launch(Dispatchers.IO)`
	- `withContext` waits for its work to finish before moving on.  
	- `launch` does not wait at all — it runs in parallel and completes later.
	- `withContext`
		- is a suspending function.
		- That means the current coroutine stops at that line, switches to `Dispatchers.IO`, runs the block, and then resumes exactly where it left off. The key word here is **waiting**. Nothing after that line runs until the block completes.
	- `launch` 
		- creates a new coroutine and returns immediately. 
		- The current coroutine continues execution right away while the launched block executes independently. It’s a fire-and-continue pattern. There is no waiting unless you explicitly call `join()` on the launched coroutine.
	- Sequential execution with `withContext` is safer when updating shared objects
	- Parallel writes can cause race conditions unless the cache itself is thread-safe.
	- Room DAO methods and Retrofit suspend functions do not require `withContext(Dispatchers.IO)`. Because these libraries reduce manual dispatcher switching, developers see fewer explicit differences between coroutine builders.
	- `launch` reports exceptions to its parent scope. If that scope has a supervisor or custom exception handler, the effect is different. The exception does not interrupt the caller’s execution path immediately.
	- `withContext` throws exceptions directly in the caller coroutine. They are not delayed or stored.
	- `launch` reports exceptions to its parent scope. If that scope has a supervisor or custom exception handler, the effect is different. The exception does not interrupt the caller’s execution path immediately.
	- ## What to remember
		- `withContext` **waits** for the block to finish before moving on.
		- `launch` starts **parallel** work and returns immediately.
		- Use `withContext` when the **result or order** matters.
		- Use `launch` when you want **concurrent work** that does not need to block the caller.
		- Visual similarity hides behavioral differences — the coroutine builder defines the semantics, not the dispatcher.

2. Identify current scroll position in RecyeclerView:
	- Use `LinearLayoutManager` to detect which item is visible.
	- Add `OnScrollListener` to track item while scrolling.
		`recyclerView.addOnScrollListener(object : RecyclerView.OnScrollListener(){`
			`override fun onScrolled(rv: RecyclerView, dx: Int, dy: Int) {`
			`val lm = rv.layoutManager as LinearLayoutManager`
			`val first = lm.findFirstVisibleItemPosition()`
			`val last = lm.findLastVisibleItemPosition()`
			`val center = (first + last) / 2`
			`onItemVisible(center)`
			
		`})`
	
	- `center` = item user is currently viewing.
	- layoutManager.findFirstVisibleItemPosition()