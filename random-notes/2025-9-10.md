CoroutineScope(SupervisorJob()) → Default.
lifecycleScope.launch { ... } → Main.immediate.
viewModelScope.launch { ... } → Main.immediate.

10 Android Security Tips: Must read for android developers
	Application Sandbox: Each app runs in its own isolated environment with a unique User ID
	Robust Framework: Battle-tested implementations of cryptography, permissions, and secure IPC
	Memory Protection: Technologies like ASLR, NX, and ProPolice that mitigate memory corruption attacks
	Permission System: Fine-grained control over system resources and user data

	1. Secure Communication: The Foundation of Trust
		Enforce HTTPS Everywhere: val connection = url.openConnection() as HttpsURLConnection
		Network Security Configuration: Your Digital Bouncer
			<application 
    				android:networkSecurityConfig="@xml/network_security_config">
			</application>

	2. Smart Permission Management: Ask for Less, Get More Trust	
		The Golden Rule: Minimal Permissions
		Signature-Based Permissions for Your App Ecosystem

	3. Data Storage: Your Digital Vault
		Internal Storage: The Gold Standard
			For sensitive data, internal storage is your fortress. It’s automatically sandboxed and accessible only 
			to your app
		External Storage: Handle with Care -> Use Hash algorithm

	4. Authentication: The Modern Approach
		Embrace Passkeys and Credential Manager
			val credentialManager = CredentialManager.create(this)
		Biometric Authentication for High-Value Operations

	5. Inter-App Communication: Trust but Verify
		App Choosers for Sensitive Data
			When sharing sensitive information between apps, always show an app chooser

		Content Providers: Lock Down by Default
			Unless you specifically need to share data with other apps, keep your content providers private

BroadcastReceiver vs Repository:
	Old approach: Service used LocalBroadcastManager + BroadcastReceiver to push download progress/events → outdated & verbose.
 	New approach: Use a Repository + DownloadInfoStreams (Flow) → ViewModel observes → UI updates. Cleaner, lifecycle-aware, 
		no broadcasts needed.

 	Service refactor:
 		Removed all LocalBroadcastManager logic.
 		Service only calls QuranDownloadNotifier → DownloadInfoStreams.emitEvent.
 		DownloadRepository listens to the stream and exposes StateFlow<DownloadUiState>.
	
 	Improvements:
 		Reset isDownloadCanceled = false when starting new downloads.
 		Replace okhttp3.internal.closeQuietly with Kotlin use {} (safe auto-close).
 		Simplify file read loop with read(...) != -1L instead of exhausted().
 	Avoid “magic constants”: extract update frequency (5) into a named constant like PROGRESS_UPDATE_INTERVAL.
	
 	Result: Modern MVVM-friendly download flow, robust I/O handling, no deprecated/brittle APIs, easier to maintain.

If the repo owns global state → repo StateFlow (read-only) is good. 
If the state is per-screen or needs VM control → expose Flow from repo and stateIn in VM.