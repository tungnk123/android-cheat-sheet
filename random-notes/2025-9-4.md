By default, each app runs in its own Linux process (sandbox)
	Each installed Android application is assigned a unique Linux user ID (UID).
	This UID isolates its files, memory, and resources, creating a sandbox.

	Inside that process, the Android runtime (Dalvik/ART) executes the app’s bytecode.

	Scheduler (Linux Kernel): handle the sharing of a CPU’s processing time

	Context switch = a thread change
    		A context switch starts by storing the state of the executing thread so that the execution can be resumed at a 
		later point, whereafter that thread has to wait.
    		The scheduler then restores another waiting thread for processing.

“Design a news app that fetches articles from multiple sources and supports offline mode.”
	Architecture: MVVM + Repository Pattern.
	Networking: Retrofit.
	Offline Mode: Room database + WorkManager for background sync.
	Scalability: Paging3 for infinite scroll, modularized codebase.
	Testing: Fake Repository for ViewModel tests.

	“How would you scale this if 1M users joined tomorrow?”
	-> Use OkHttp caching, CDNs for static assets, and optimized DB queries.

Offline-first application:
	Local DB is the Single Source of Truth (SSOT). UI always reads from Room.
	Reads: Observe Room Flow. In parallel, fetch from network → upsert into Room → UI updates automatically.
	Writes: Optimistic: write to Room immediately and enqueue an Outbox record. 
		A background worker syncs the Outbox to the server and reconciles results.

	@Entity(tableName = "outbox")
	data class OutboxItem(
   	@PrimaryKey val localOpId: String = UUID.randomUUID().toString(),
    		val op: String,              // "CREATE" | "UPDATE" | "DELETE"
    		val payload: String,         // JSON payload (Note or patch)
    		val createdAt: Long = System.currentTimeMillis(),
    		val retryCount: Int = 0
	)

	Read Flow:
	emitAll(queryLocal())
    	try {
        	val remote = fetchRemote()
        	saveRemote(remote)
    	} catch (_: Throwable) { /* stay offline gracefully */ }
    	emitAll(queryLocal())

	OutboxSyncWorker -> repo.flushOutbox() -> send outbox operations to server
	(Trigger this when you enqueue an Outbox item, on connectivity changes, or on pull-to-refresh.)

	Conflict resolution options
		LWW (Last-Write-Wins) via updatedAt (simple, pragmatic).
		Server-version / ETag: server rejects stale updates → client merges and retries.
		CRDT for merge-friendly data (counters/sets) if you need eventual consistency at scale.
	Merge rule sketch:
		If remote.updatedAt > local.updatedAt → accept remote.
		If local has pending Outbox ops, prefer local until sync succeeds, then fetch again.

	Idempotency keys for CREATE (UUID) to avoid duplicates on retries.
	Exponential backoff + cap retryCount in Outbox.

Long running tasks:
	network
	file
	database
	sharedpreference, datastore
	intensive CPU tasks: image processing, text parser