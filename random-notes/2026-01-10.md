1. **Kotlin Interview Question: How to Return Two Values**
	- you need to **return multiple values** from a function
	- Kotlin provides **clean ways to return two or more values** using **Pair, Triple, data classes, and more**.
	- 1. Pair:
		- ✅ **Pros:** Simple, built-in, quick to use.  
		- ⚠️ **Cons:** `first` and `second` aren’t very descriptive unless you de-structure.
	- 2. Data class (RECOMMENDED):
		- **data class more readable and maintainable code**, you can define a **data class** to hold multiple values and return it from a function.
		- ✅ **Pros:**
			- Self-documenting and readable
			- Scalable for more than two values
			- Supports destructuring
		- ⚠️ **Cons:**
			- Slight overhead of creating a separate class, but it’s negligible for clarity and maintainability.
	- 3. Using Triple:
		- 3 values
		- like pair
	- 4. **Using a List or Map** (Less Common)
		- less descriptive
	- In short:
		- Use data class for readable and scalable option
		- Use destructuring makes accessing values more clean and easy
2. Virtusa Android Interview — Kotlin & Android Core Explained Simply
	- SSL Pining in Android:
		- Trust only specific sever certificates
		- Prevent Man-In-The-Middle attack
3. Activity lifecycle states?
	- The Activity lifecycle defines how Android creates, displays, pauses, and destroys a screen. Correct usage ensures good performance, no leaks, and a smooth user experience.
	- **onCreate()**  
		- Called **once** when the Activity is created.  
		- Used for **one-time initialization** such as:
			- Dependency injection (Hilt)
			- Initializing ViewModels
			- Setting the UI with `setContentView()` or `setContent {}`  
		- The UI is not yet visible, so no user interaction or heavy work should start here.
	- **onStart()**  
	     - The Activity becomes **visible** to the user but is not yet interactive.  
	     - This is a good place to prepare UI-related resources or start observing data.
	 - **onResume()**  
	     - The Activity is in the **foreground and fully interactive**.  
	     - This is the best place to:
			- Start sensors, camera, or location updates
			- Perform **foreground data synchronization**
			- Resume animations or real-time updates  
			     Any work here should stop automatically when the user leaves the screen.
	 - **onPause()**  
		 - Called when the Activity is about to lose focus.  
		-  Used to **pause or suspend** ongoing work such as:
			- Camera or AR previews
			- Sensor listeners  
			-  This method must execute quickly to avoid ANRs.
	- **onStop()**  
		- The Activity is no longer visible.  
		- Used to stop or release UI-related resources like media playback.
	- **onDestroy()**  
	     - Final cleanup when the Activity is destroyed.  
	     - Used to release remaining resources, but it is **not reliable** for saving critical data because the system may kill the process without calling it.
	 - **Where I place data syncs?**
		 - I start foreground data syncing when the Activity is **resumed**, so it runs only while the user is actively viewing the screen and stops automatically when the screen is paused.
		 - repeatOnLifecycle
		 - `SavedStateHandle`
	 - By aligning data syncing and resource usage with the Activity lifecycle, we ensure optimal **performance**, **battery** efficiency, and **correctness**, even at large scale.

```kotlin fold title:test
	fun a() {
		return 0
	}
```