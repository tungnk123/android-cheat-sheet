Constant Naming Guideline
	Pattern:
 		SUBJECT_DESCRIPTION[_LIMIT][_UNIT]
 		SUBJECT → what it applies to (PASS, API, USER)
 		DESCRIPTION → what the value is (PROCESSING_DELAY, TIMEOUT)
 		LIMIT (optional) → qualifier like DEFAULT, MAX, MIN
 		UNIT (optional but recommended) → explicit unit (_MILLIS, _SECONDS)
	Best Practices
 		Use uppercase with underscores.
 		Always include unit when numeric values represent time or size.
 		Add DEFAULT, MAX, MIN for constraints and clarity.
 		Prefer _MILLIS in Kotlin/Android when using Long in ms.
	Examples
		const val PASS_PROCESSING_DELAY_DEFAULT_MILLIS = 3_000L
		const val FORECAST_PASS_PROCESSING_DELAY_MAX_MILLIS = 7_000L
		const val API_REQUEST_TIMEOUT_DEFAULT_SECONDS = 30
		const val API_REQUEST_TIMEOUT_MAX_SECONDS = 60
		const val USERNAME_LENGTH_MIN = 3
		const val USERNAME_LENGTH_MAX = 20

Room:
	When the return type is Flow<T>, querying an empty table throws a null pointer exception.
	When the return type is Flow<T?>, querying an empty table emits a null value.
	When the return type is Flow<List<T>>, querying an empty table emits an empty list.


Classic Android lifecycle vs AndroidX Lifecycle (KTX) states
	Classic lifecycle = callbacks you override (onCreate, onStart, onResume, onPause, onStop, onDestroy) and old diagrams that 
		show “Paused” and “Stopped” phases.

	AndroidX Lifecycle (KTX) = a state machine (Lifecycle.State) that libraries (Flow/LiveData/Navigation/ViewPager2) use to 
		start/stop work declaratively.

	onCreate() -> CREATED
	onStart() -> STARTED
	onResume() -> RESUMED
	onPause() -> back to STARTED (no PAUSED state in AndroidX)
	onStop() -> CREATED
	onDestroy() -> DESTROYED

	repeatOnLifecycle(State.RESUMED) → runs only when the screen is visible & interactive (current tab).
	repeatOnLifecycle(State.STARTED) → runs when the screen is visible but not in focus and when in focus. With ViewPager2, 		
		offscreen pages (within offscreenPageLimit) are kept at STARTED, so those blocks still run.
	Use RESUMED for heavy/interactive streams on pages/tabs; use STARTED when you want them active while visible but not focused.

	Current page: adapter sets maxLifecycle = RESUMED.
	Neighboring pages within offscreenPageLimit: STARTED (View exists; onPause() called; no onStop()).
 	Pages outside the limit: view destroyed (onDestroyView()), lifecycle ≤ CREATED.
	
	ViewPager2 specifics
 		Current page: adapter sets maxLifecycle = RESUMED.
		Neighboring pages within offscreenPageLimit: STARTED (View exists; onPause() called; no onStop()).
		Pages outside the limit: view destroyed (onDestroyView()), lifecycle ≤ CREATED.

	Classic Paused → AndroidX STARTED (post-onPause).
 	Classic Stopped → AndroidX CREATED (post-onStop).


Kotlin Multiplatform (KMP) → Share business logic (networking, database, domain). UI is native per platform (Jetpack Compose on Android, 
	SwiftUI on iOS, etc.). Best when you want maximum native feel.

Compose Multiplatform (CMP) → Share both UI and logic across Android, iOS, Desktop, and Web. One codebase for everything. 
	Best for speed and smaller teams.

Jetpack Compose (JC) → Android-only UI framework. Deeply integrated with Android ecosystem. Best choice if your app is Android-first.