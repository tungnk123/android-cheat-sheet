DI Module
	class that defines how dependencies should be provided in a Dependency Injection (DI) framework
	a DI module is a class annotated with @Module where you can declare methods that provide dependencies to be injected 		into various parts of your application.
	
	@Provides
		you need to create a dependency using some logic inside the method. This logic might involve calling 			constructors, configuring objects, or performing computations.

	@Binds
		Use @Binds when you want to bind an implementation to an interface or abstract class. This method should be 		abstract and only have one parameter which is the implementation type.

	What is @InstallIn?
		@InstallIn annotation is used to specify the Hilt component in which a module should be installed
		This determines the scope and lifetime of the dependencies provided by the module
		
	SingletonComponent:
		Scope: Application-wide
		Lifetime: As long as the application is running
		Usage: For dependencies that should live as long as the application, such as singletons

	ActivityComponent:
		Scope: Activity
		Lifetime: As long as the activity is alive
		Usage: For dependencies that should live as long as the activity, such as ViewModels or other activity-			scoped objects

	FragmentComponent:
		Scope: Fragment
		Lifetime: As long as the fragment is alive

	ViewComponent:
		Scope: View
		Lifetime: As long as the view is alive


	ServiceComponent:
		Scope: Service
		Lifetime: As long as the service is running

	BroadcastReceiverComponent:
		Scope: Broadcast Receiver
		Lifetime: As long as the broadcast receiver is handling a broadcast


	Purpose of Custom Qualifiers
		When you have multiple bindings of the same type, Hilt (or Dagger) needs a way to distinguish between them



Refactoring with Kotlin:
	improve code readability and simplify its maintenance
	code smell = short issues or shortcoming in its implementation
	=> doesn't mean to have bugs, but the smell makes code understanding, developong and maintainance much more complex
	Ignore code smell -> increase technical debt
	=> refactoring improve the codebase's quality and makes it clearer and more extensible

	Example: long method, long parameter list, duplicated code, feature envy, god class, ...

	Ctrl + Alt + Shift + T
	
	
	editor config file
